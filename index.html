<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=6.7.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Aaron&#39;s Blog">
<meta property="og:url" content="http://aaron-codes.github.io/index.html">
<meta property="og:site_name" content="Aaron&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Aaron&#39;s Blog">






  <link rel="canonical" href="http://aaron-codes.github.io/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Aaron's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aaron's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">人必有痴，而后有成。</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

    
    
      
      
    
      
      
    
    

  


          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2018/07/06/2018-07-06/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/06/2018-07-06/" class="post-title-link" itemprop="url">转载 -《管理自己》-《Managing Oneself》</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-06 14:09:10 / 修改时间：14:12:48" itemprop="dateCreated datePublished" datetime="2018-07-06T14:09:10+08:00">2018-07-06</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/live/" itemprop="url" rel="index"><span itemprop="name">live</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="转载_-《管理自己》-《Managing_Oneself》">转载 -《管理自己》-《Managing Oneself》</h1><h2 id="0、前言">0、前言</h2><p>　我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。</p>
<p>　　不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。</p>
<p>　　历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而<strong><em>我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。</em></strong></p>
<p>　　我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。
　　</p>
<h2 id="1、我的长处是什么？">1、我的长处是什么？</h2><p> <strong><em>多数人都以为他们知道自己擅长什么，其实不然。</em></strong>更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情。</p>
<p>　　以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。</p>
<p>　　要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。<br>　　<img src="http://7xigvj.com1.z0.glb.clouddn.com/15308561017351.jpg" alt=""><br>　　<br>比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。</p>
<p>　　回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。</p>
<p>　　<strong><em>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。</em></strong>在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。</p>
<p>　　根据回馈分析的启示，你需要在几方面采取行动。</p>
<p>　　首先，最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。</p>
<p>　　其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。</p>
<p>　　第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。</p>
<p>　　<strong><em>另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。</em></strong>例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。</p>
<p>　　与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。</p>
<p>　　<strong><em>把预期和实际结果进行比较，也会发现自己不擅长做什么。</em></strong> 我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该<strong><em>尽量少把精力浪费在那些不能胜任的领域上，因为“从无能到平庸”要比“从一流到卓越”需要人们付出多得多的努力。</em></strong>然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。
　　</p>
<h2 id="2、我的工作方式是怎样的？">2、我的工作方式是怎样的？</h2><p>令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。</p>
<p>　　同一个人的长处一样，<strong><em>一个人的工作方式也是独一无二的——这是由人的个性所决定的。</em></strong> 不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。<strong><em>正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。</em></strong>而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。<br>　　<img src="http://7xigvj.com1.z0.glb.clouddn.com/15308563832179.jpg" alt="">
　　</p>
<blockquote>
<p>我属于读者型，还是听者型？</p>
</blockquote>
<p>首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有“读者型”和“听者型”之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。</p>
<p>　　德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。</p>
<p>　　艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。</p>
<p>　　几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。</p>
<p>　　没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力；反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。
　　</p>
<h2 id="3、我如何学习？">3、我如何学习？</h2><blockquote>
<p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。</p>
</blockquote>
<p>许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。</p>
<p>　　所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。</p>
<p>　　像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。</p>
<p>　　我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。</p>
<p>　　在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。</p>
<p>　　我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？</p>
<p>　　有些人适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长（可能也是美国历史上最成功的伯乐）乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。”</p>
<p>　　一些人作为团队成员工作最出色；另一些人单独工作最出色。一些人当教练和导师特别有天赋；另一些人却没能力做导师。</p>
<p>　　另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？</p>
<p>　　许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。</p>
<p>　　顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。</p>
<p>　　其他有助于认识自我的重要问题包括：</p>
<ol>
<li>我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？</li>
<li>我是在一个大公司还是在一个小公司中工作表现最佳？</li>
<li>在各种环境下都工作出色的人寥寥无几。</li>
</ol>
<p>　我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15308566469892.jpg" alt=""></p>
<h2 id="4、我的价值观是什么？">4、我的价值观是什么？</h2><p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。</p>
<p>　　20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。”——这就是镜子测试。<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15308566689088.jpg" alt=""></p>
<p>我们所遵从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。</p>
<p>　　如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。</p>
<p>　　让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。</p>
<p>　　同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。</p>
<p>　　至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。</p>
<p>　　价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，其衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。</p>
<p>　　这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题（至少首先并不是神学问题），而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。”而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。”</p>
<p>　　<strong><em>组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。</em></strong> 不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。</p>
<p>　　一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。</p>
<p>　　如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。</p>
<h2 id="5、我属于何处？">5、我属于何处？</h2><p>少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，<strong><em>大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。</em></strong> 然而，到这个时候，他们应该知道上面所谈的三个问题的答案：</p>
<ol>
<li>我的长处是什么？</li>
<li>我的工作方式是怎样的？</li>
<li>我的价值观是什么？</li>
</ol>
<p>随后，他们就能够决定自己该向何处投入精力。或者，他们应该能够决定自己不属于何处。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15308569369665.jpg" alt=""></p>
<p>已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。</p>
<p>　　同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。他们会说：“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。”</p>
<p>　　<strong><em>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。</em></strong> 知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。</p>
<h2 id="6、我该做什么贡献？">6、我该做什么贡献？</h2><p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。</p>
<p>　　以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”，organization man）还指望公司的人事部为他们做职业规划。</p>
<p>　　随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。</p>
<p>　　尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：</p>
<ol>
<li>当前形势的要求是什么？</li>
<li>鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？</li>
<li>必须取得什么结果才能产生重要影响？</li>
</ol>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15308570256491.jpg" alt=""></p>
<p>请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。</p>
<p>　　正如这个事例所表明的，<strong><em>把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了18个月，就很难做到明确和具体。</em></strong> 因此，在多数情况下我们应该提出的问题是：</p>
<ol>
<li>我在哪些方面能取得将在今后一年半内见效的结果？</li>
<li>如何取得这样的结果？<br>　<br>　回答这个问题时必须对几个方面进行权衡：</li>
</ol>
<p>　　首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力”（stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。</p>
<p>　　其次，这些结果应该富有意义，要能够产生一定影响。</p>
<p>　　最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。
　　</p>
<h2 id="7、我要如何处理人际关系？">7、我要如何处理人际关系？</h2><p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。</p>
<p>　　首先是要接受：别人是和你一样的个体这个事实。</p>
<p>　　每个人都会执意展现自己作为人的个性。这就是说，每个人都有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。<br>　　<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15308571441723.jpg" alt=""></p>
<p>一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。</p>
<p>　　老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任<strong><em>观察他们，了解他们的工作方式，并做出相应的自我调整，以适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。</em></strong></p>
<p>　　这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。</p>
<p>　　人际关系责任的第二部分内容是沟通责任。</p>
<p>　　在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。</p>
<p>　　在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。</p>
<p>　　而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。</p>
<p>　　如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。</p>
<p>　　即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？”</p>
<p>　　如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？”</p>
<p>　　<strong><em>组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。</em></strong> 因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。
　　</p>
<h2 id="8、我该如何管理后半生？">8、我该如何管理后半生？</h2><p>当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。</p>
<p>　　我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。</p>
<p>　　发展第二职业有三种方式：<br>　　<img src="http://7xigvj.com1.z0.glb.clouddn.com/15308572548625.jpg" alt=""></p>
<p>第一种是完全投身于新工作。</p>
<p>　　这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。</p>
<p>　　为后半生做准备的第二种方式是，发展一个平行的职业。</p>
<p>　　许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。</p>
<p>　　最后一种方法是社会创业。</p>
<p>　　社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。</p>
<p>　　<strong><em>能管理好自己后半生的人总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。</em></strong> 但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。</p>
<p>　　<strong><em>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。</em></strong> 当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。</p>
<p>　　同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。</p>
<p>　　发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——还可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。</p>
<p>　　在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。</p>
<p>　　自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，<strong><em>自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。</em></strong> 更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。</p>
<p>　　历史上每一个社会，甚至是个人主义倾向最强的社会，都认为（即使只是下意识地认为）两件事情是理所当然的：</p>
<ol>
<li>组织比员工更长寿；</li>
<li>大多数人从不挪地方。</li>
</ol>
<p>如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命。
　　</p>
<h2 id="附录">附录</h2><p><a href="https://goo.gl/iTr6U9" target="_blank" rel="noopener">德鲁克谈《自我管理》——《哈佛商业评论》史上最受欢迎的文章</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2018/07/06/2018-07-09/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/06/2018-07-09/" class="post-title-link" itemprop="url">Hive 笔试题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-06 14:09:10" itemprop="dateCreated datePublished" datetime="2018-07-06T14:09:10+08:00">2018-07-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-10 14:48:24" itemprop="dateModified" datetime="2018-07-10T14:48:24+08:00">2018-07-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="Hive_笔试题">Hive 笔试题</h1><p>考试时间：   姓名：<strong><strong><em>__</em></strong></strong></p>
<p>考试成绩：<strong><strong><em>__</em></strong></strong>   考试时长：180 分钟</p>
<p>注意事项：</p>
<ol>
<li><p>自主答题，不能参考任何除本试卷外的其它资料。</p>
</li>
<li><p>总成绩共 200 分，共 20 题，每题 10 分，注意条理清楚、简明扼要、重点突出。</p>
</li>
</ol>
<h2 id="1-_Hive_的架构设计与运行流程，及其各模块的主要作用是什么，请画出架构图">1.  Hive 的架构设计与运行流程，及其各模块的主要作用是什么，请画出架构图</h2><p>Hive是基于Hadoop的数据仓库，使用HQL作为查询接口、HDFS作为存储底层、mapReduce作为执行层， 基于Hadoop平台解决了企业数据仓库构建的核心技术问题，证明了Hadoop平台的强大。从而进一步降低了Hadoop使用的准入门槛。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15311190753401.jpg" alt=""></p>
<ul>
<li>用户接口主要有三个：CLI命令行，Client 和 Web UI</li>
<li>metaStore: hive 的元数据结构描述信息库，可选用不同的关系型数据库来存储，通过配置文件修改、查看数据库配置信息</li>
<li>Driver: hive核心驱动器接口类，衔接UI与内核的解析、优化、执行器的桥梁，生成的查询计划存储在HDFS中，并在随后由MapReduce调用执行</li>
</ul>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15311191181571.jpg" alt=""></p>
<h2 id="2-_Hive_的数据模型组成，及各组成模块的应用场景，请简要描述">2. Hive 的数据模型组成，及各组成模块的应用场景，请简要描述</h2><p>Hive 中所有的数据都存储在 HDFS 中， Hive 中包含以下数据模型： Table ， External Table ， Partition ， Bucket 。</p>
<ul>
<li>Hive 中的 Table 和数据库中的 Table 在概念上是类似的，每一个 Table 在 Hive 中都有一个相应的目录存储数据。例如，一个表 pvs ，它在 HDFS 中的路径为： /wh/pvs ，其中， wh 是在 hive-site.xml 中由 ${hive.metastore.warehouse.dir} 指定的数据仓库的目录，所有的 Table 数据（不包括 External Table ）都保存在这个目录中。</li>
<li>Partition 对应于数据库中的 Partition 列的密集索引，但是 Hive 中 Partition 的组织方式和数据库中的很不相同。在 Hive 中，表中的一个 Partition 对应于表下的一个目录，所有的 Partition 的数据都存储在对应的目录中。例如： pvs 表中包含 ds 和 city 两个 Partition ，则对应于 ds = 20090801, ctry = US 的 HDFS 子目录为： /wh/pvs/ds=20090801/ctry=US ；对应于 ds = 20090801, ctry = CA 的 HDFS 子目录为；/wh/pvs/ds=20090801/ctry=CA</li>
<li>Buckets 对指定列计算 hash ，根据 hash 值切分数据，目的是为了并行，每一个 Bucket 对应一个文件。将 user 列分散至 32 个 bucket ，首先对 user 列的值计算 hash ，对应 hash 值为 0 的 HDFS 目录为： /wh/pvs/ds=20090801/ctry=US/part-00000 ； hash 值为 20 的 HDFS 目录为： /wh/pvs/ds=20090801/ctry=US/part-00020</li>
<li>External Table 指向已经在 HDFS 中存在的数据，可以创建 Partition 。它和 Table 在元数据的组织上是相同的，而实际数据的存储则有较大的差异。</li>
<li>Table 的创建过程和数据加载过程（这两个过程可以在同一个语句中完成），在加载数据的过程中，实际数据会被移动到数据仓库目录中；之后对数据对访问将会直接在数据仓库目录中完成。删除表时，表中的数据和元数据将会被同时删除。</li>
<li>External Table 只有一个过程，加载数据和创建表同时完成（ CREATE EXTERNAL TABLE ……LOCATION ），实际数据是存储在 LOCATION 后面指定的 HDFS 路径中，并不会移动到数据仓库目录中。当删除一个 External Table 时，仅删除元信息。</li>
</ul>
<h2 id="3-_Hive_支持的文件格式和压缩格式，及其各自的特点？">3.  Hive 支持的文件格式和压缩格式，及其各自的特点？</h2><ul>
<li>存储格式，hive默认支持三种从存储格式，当然用户根据需要可以自定义存储格式。</li>
</ul>
<table>
<thead>
<tr>
<th>存储格式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEQUENCEFILE</td>
<td>可压缩可分割二进制文件</td>
<td>需要一个合并文件的过程，且合并后的文件将不方便查看</td>
</tr>
<tr>
<td>TEXTFILE</td>
<td>简单方便查看</td>
<td>-</td>
</tr>
<tr>
<td>RCFILE</td>
<td>按列查找，理论上对于宽表采用这个比较好</td>
<td>比较新,还没有广泛应用</td>
</tr>
</tbody>
</table>
<ul>
<li>压缩格式</li>
</ul>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>工具</th>
<th>算法</th>
<th>文件扩展名</th>
<th>多文件</th>
<th>可分割性</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFLATE*</td>
<td>无</td>
<td>DEFLATE</td>
<td>.deflate</td>
<td>不</td>
<td>不</td>
</tr>
<tr>
<td>Gzip</td>
<td>gzip</td>
<td>DEFLATE</td>
<td>.gz</td>
<td>不</td>
<td>不</td>
</tr>
<tr>
<td>ZIP</td>
<td>zip</td>
<td>DEFLATE</td>
<td>.zip</td>
<td>是</td>
<td>是，在文件范围内</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>不</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>lzop</td>
<td>LZO</td>
<td>.lzo</td>
<td>不</td>
<td>不</td>
</tr>
</tbody>
</table>
<ul>
<li>例子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE EXTERNAL TABLE src( key string, value string ) ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;5&apos; LINES TERMINATED BY &apos;\n&apos;STORED AS RCFileALTER TABLE src SET SERDEPROPERTIES (&apos;serialization.null.format&apos;=&apos;&apos;);</span><br><span class="line">set mapred.reduce.tasks=200;</span><br><span class="line">set io.sort.mb=500;</span><br><span class="line">set mapred.output.compression.codec=org.apache.hadoop.io.compress.BZip2Codec;</span><br><span class="line"></span><br><span class="line">INSERT OVERWRITE TABLE src_bzip2SELECT * FROM src SORT BY key;</span><br></pre></td></tr></table></figure>
<h2 id="4-_Hive_内外表的区分方法，及内外表的差异点？">4.  Hive 内外表的区分方法，及内外表的差异点？</h2><ul>
<li><p>异同点：</p>
<ol>
<li>创建表的语句上外部表会有一个 external 的关键字。</li>
<li>删除表的时候，内部表不仅会删除元数据，还会会将hdfs上对应的目录删除掉，而外部表只是删除了元数据，并不会删除 hdfs 上的数据</li>
</ol>
</li>
</ul>
<h2 id="5-_Hive_视图如何创建，视图有什么特点，及其应用场景？">5. Hive 视图如何创建，视图有什么特点，及其应用场景？</h2><p>Hive中的视图和关系型数据库一样，Hive中也提供了视图的功能，注意Hive中视图的特性，和关系型数据库中的稍有区别：</p>
<p>只有逻辑视图，没有物化视图；<br>视图只能查询，不能Load/Insert/Update/Delete数据；<br>视图在创建时候，只是保存了一份元数据，当查询视图的时候，才开始执行视图对应的那些子查询；</p>
<h2 id="6-_Hive_常用的_12_个命令，及其作用">6. Hive 常用的 12 个命令，及其作用</h2><ul>
<li>创建表：</li>
</ul>
<p>hive&gt; CREATE TABLE pokes (foo INT, bar STRING);<br>        Creates a table called pokes with two columns, the first being an integer and the other a string</p>
<ul>
<li>创建一个新表，结构与其他一样</li>
</ul>
<p>hive&gt; create table new_table like records;</p>
<ul>
<li>创建分区表：</li>
</ul>
<p>hive&gt; create table logs(ts bigint,line string) partitioned by (dt String,country String);</p>
<ul>
<li>加载分区表数据：</li>
</ul>
<p>hive&gt; load data local inpath ‘/home/hadoop/input/hive/partitions/file1’ into table logs partition (dt=’2001-01-01’,country=’GB’);</p>
<ul>
<li><p>展示表中有多少分区：<br>hive&gt; show partitions logs;</p>
</li>
<li><p>展示所有表：</p>
</li>
</ul>
<p>hive&gt; SHOW TABLES;<br>        lists all the tables<br>hive&gt; SHOW TABLES ‘.*s’;</p>
<p>lists all the table that end with ‘s’. The pattern matching follows Java regular<br>expressions. Check out this link for documentation <a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html</a></p>
<ul>
<li>显示表的结构信息</li>
</ul>
<p>hive&gt; DESCRIBE invites;<br>        shows the list of columns</p>
<ul>
<li>更新表的名称：</li>
</ul>
<p>hive&gt; ALTER TABLE source RENAME TO target;</p>
<ul>
<li>添加新一列</li>
</ul>
<p>hive&gt; ALTER TABLE invites ADD COLUMNS (new_col2 INT COMMENT ‘a comment’);</p>
<ul>
<li>删除表：</li>
</ul>
<p>hive&gt; DROP TABLE records;</p>
<ul>
<li>删除表中数据，但要保持表的结构定义</li>
</ul>
<p>hive&gt; dfs -rmr /user/hive/warehouse/records;</p>
<ul>
<li>从本地文件加载数据：</li>
</ul>
<p>hive&gt; LOAD DATA LOCAL INPATH ‘/home/hadoop/input/ncdc/micro-tab/sample.txt’ OVERWRITE INTO TABLE records;</p>
<ul>
<li>显示所有函数：</li>
</ul>
<p>hive&gt; show functions;</p>
<ul>
<li>查看函数用法：</li>
</ul>
<p>hive&gt; describe function substr;</p>
<ul>
<li>查看数组、map、结构</li>
</ul>
<p>hive&gt; select col1[0],col2[‘b’],col3.c from complex;</p>
<ul>
<li>内连接：</li>
</ul>
<p>hive&gt; SELECT sales.<em>, things.</em> FROM sales JOIN things ON (sales.id = things.id);</p>
<ul>
<li>查看hive为某个查询使用多少个MapReduce作业</li>
</ul>
<p>hive&gt; Explain SELECT sales.<em>, things.</em> FROM sales JOIN things ON (sales.id = things.id);</p>
<ul>
<li>外连接：</li>
</ul>
<p>hive&gt; SELECT sales.<em>, things.</em> FROM sales LEFT OUTER JOIN things ON (sales.id = things.id);<br>hive&gt; SELECT sales.<em>, things.</em> FROM sales RIGHT OUTER JOIN things ON (sales.id = things.id);<br>hive&gt; SELECT sales.<em>, things.</em> FROM sales FULL OUTER JOIN things ON (sales.id = things.id);</p>
<ul>
<li>in查询：Hive不支持，但可以使用LEFT SEMI JOIN</li>
</ul>
<p>hive&gt; SELECT * FROM things LEFT SEMI JOIN sales ON (sales.id = things.id);</p>
<ul>
<li>Map连接：Hive可以把较小的表放入每个Mapper的内存来执行连接操作</li>
</ul>
<p>hive&gt; SELECT /<em>+ MAPJOIN(things) </em>/ sales.<em>, things.</em> FROM sales JOIN things ON (sales.id = things.id);</p>
<p>INSERT OVERWRITE TABLE ..SELECT：新表预先存在<br>hive&gt; FROM records2</p>
<pre><code>&gt; INSERT OVERWRITE TABLE stations_by_year <span class="keyword">SELECT</span> year, COUNT(<span class="keyword">DISTINCT</span> station) <span class="keyword">GROUP</span> <span class="keyword">BY</span> year 
&gt; INSERT OVERWRITE TABLE records_by_year <span class="keyword">SELECT</span> year, COUNT(<span class="number">1</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> year
&gt; INSERT OVERWRITE TABLE good_records_by_year <span class="keyword">SELECT</span> year, COUNT(<span class="number">1</span>) <span class="keyword">WHERE</span> temperature != <span class="number">9999</span> <span class="keyword">AND</span> (quality = <span class="number">0</span> <span class="keyword">OR</span> quality = <span class="number">1</span> <span class="keyword">OR</span> quality = <span class="number">4</span> <span class="keyword">OR</span> quality = <span class="number">5</span> <span class="keyword">OR</span> quality = <span class="number">9</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> year;  
</code></pre><p>CREATE TABLE … AS SELECT：新表表预先不存在<br>hive&gt;CREATE TABLE target AS SELECT col1,col2 FROM source;</p>
<ul>
<li>创建视图：</li>
</ul>
<p>hive&gt; CREATE VIEW valid_records AS SELECT * FROM records2 WHERE temperature !=9999;</p>
<ul>
<li>查看视图详细信息：</li>
</ul>
<p>hive&gt; DESCRIBE EXTENDED valid_records;</p>
<h2 id="7-_Hive_常用的_10_个系统函数，及其作用">7. Hive 常用的 10 个系统函数，及其作用</h2><p><a href="https://www.iteblog.com/archives/1639.html" target="_blank" rel="noopener">Hive常用字符串函数</a></p>
<p>Hive分析窗口函数(一) SUM,AVG,MIN,MAX<br>Hive分析窗口函数(二) NTILE,ROW_NUMBER,RANK,DENSE_RANK<br>Hive分析窗口函数(三) CUME_DIST,PERCENT_RANK<br>Hive分析窗口函数(四) LAG,LEAD,FIRST_VALUE,LAST_VALUE<br>Hive分析窗口函数(五) GROUPING SETS,GROUPING__ID,CUBE,ROLLUP</p>
<h2 id="8-_请详细描述将一个有结构的文本文件_student-txt_导入到一个_Hive_表当中的步骤，及其关键字？">8. 请详细描述将一个有结构的文本文件 student.txt 导入到一个 Hive 表当中的步骤，及其关键字？</h2><p>一、从本地文件系统中导入数据到Hive表</p>
<ul>
<li>先在Hive里面创建好表，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table wyp</span><br><span class="line">    &gt; (id int, name string,</span><br><span class="line">    &gt; age int, tel string)</span><br><span class="line">    &gt; ROW FORMAT DELIMITED</span><br><span class="line">    &gt; FIELDS TERMINATED BY &apos;\t&apos;</span><br><span class="line">    &gt; STORED AS TEXTFILE;</span><br><span class="line">OK</span><br><span class="line">Time taken: 2.832 seconds</span><br></pre></td></tr></table></figure>
<ul>
<li>这个表很简单，只有四个字段，具体含义我就不解释了。本地文件系统里面有个 /home/wyp/wyp.txt 文件，内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyp@master ~]$ cat wyp.txt</span><br><span class="line">1       wyp     25      13188888888888</span><br><span class="line">2       test    30      13888888888888</span><br><span class="line">3       zs      34      899314121</span><br></pre></td></tr></table></figure>
<ul>
<li>wyp.txt文件中的数据列之间是使用 \t 分割的，可以通过下面的语句将这个文件里面的数据导入到wyp表里面，操作如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data local inpath &apos;wyp.txt&apos; into table wyp;</span><br><span class="line">Copying data from file:/home/wyp/wyp.txt</span><br><span class="line">Copying file: file:/home/wyp/wyp.txt</span><br><span class="line">Loading data to table default.wyp</span><br><span class="line">Table default.wyp stats:</span><br><span class="line">[num_partitions: 0, num_files: 1, num_rows: 0, total_size: 67]</span><br><span class="line">OK</span><br><span class="line">Time taken: 5.967 seconds</span><br></pre></td></tr></table></figure>
<h2 id="9-_请简述_udf/udaf/udtf_是什么，各自解决的问题，及典型代表应用场景。">9. 请简述 udf/udaf/udtf 是什么，各自解决的问题，及典型代表应用场景。</h2><p>Hive自定义函数包括三种UDF、UDAF、UDTF</p>
<ul>
<li><p>UDF(User-Defined-Function) 一进一出</p>
</li>
<li><p>UDAF(User- Defined Aggregation Funcation) 聚集函数，多进一出。Count/max/min</p>
</li>
<li><p>UDTF(User-Defined Table-Generating Functions)  一进多出，如lateral view explore()</p>
</li>
</ul>
<p>使用方式 ：在HIVE会话中add 自定义函数的jar文件，然后创建function继而使用函数</p>
<h2 id="10-_udaf_的实现步骤，及其包含的主要方法，及每个方法要解决的问题，并写代码自实现聚合函数_max_函数？">10. udaf 的实现步骤，及其包含的主要方法，及每个方法要解决的问题，并写代码自实现聚合函数 max 函数？</h2><p>多行进一行出，如sum()、min()，用在group  by时</p>
<ol>
<li>必须继承</li>
</ol>
<p>　　org.apache.hadoop.hive.ql.exec.UDAF(函数类继承)</p>
<p>　　org.apache.hadoop.hive.ql.exec.UDAFEvaluator(内部类Evaluator实现UDAFEvaluator接口)</p>
<ol>
<li>Evaluator需要实现 init、iterate、terminatePartial、merge、terminate这几个函数</li>
</ol>
<p>　　init():类似于构造函数，用于UDAF的初始化</p>
<p>　　iterate():接收传入的参数，并进行内部的轮转，返回boolean</p>
<p>　　terminatePartial():无参数，其为iterate函数轮转结束后，返回轮转数据，类似于hadoop的Combiner</p>
<p>　　merge():接收terminatePartial的返回结果，进行数据merge操作，其返回类型为boolean</p>
<p>　　terminate():返回最终的聚集函数结果</p>
<h2 id="11、_hive_设置参数的方法有哪些？并列举_8_个常用的参数设置？">11、 hive 设置参数的方法有哪些？并列举 8 个常用的参数设置？</h2><p>Hive提供三种可以改变环境变量的方法，分别是：<br>（1）、修改${HIVE_HOME}/conf/hive-site.xml配置文件；<br>（2）、命令行参数；<br>（3）、在已经进入cli时进行参数声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br></pre></td><td class="code"><pre><span class="line">hive.ddl.output.format：hive的ddl语句的输出格式，默认是text，纯文本，还有json格式，这个是0.90以后才出的新配置；</span><br><span class="line"></span><br><span class="line">hive.exec.script.wrapper：hive调用脚本时的包装器，默认是null，如果设置为python的话，那么在做脚本调用操作时语句会变为python &lt;script command&gt;，null的话就是直接执行&lt;script command&gt;；</span><br><span class="line"></span><br><span class="line">hive.exec.plan：hive执行计划的文件路径，默认是null，会在运行时自动设置，形如hdfs://xxxx/xxx/xx；</span><br><span class="line"></span><br><span class="line">hive.exec.scratchdir：hive用来存储不同阶段的map/reduce的执行计划的目录，同时也存储中间输出结果，默认是/tmp/&lt;user.name&gt;/hive，我们实际一般会按组区分，然后组内自建一个tmp目录存储；</span><br><span class="line"></span><br><span class="line">hive.exec.submitviachild：在非local模式下，决定hive是否要在独立的jvm中执行map/reduce；默认是false，也就是说默认map/reduce的作业是在hive的jvm上去提交的；</span><br><span class="line"></span><br><span class="line">hive.exec.script.maxerrsize：当用户调用transform或者map或者reduce执行脚本时，最大的序列化错误数，默认100000，一般也不用修改；</span><br><span class="line"></span><br><span class="line">hive.exec.compress.output：一个查询的最后一个map/reduce任务输出是否被压缩的标志，默认为false，但是一般会开启为true，好处的话，节省空间不说，在不考虑cpu压力的时候会提高io；</span><br><span class="line"></span><br><span class="line">hive.exec.compress.intermediate：类似上个，在一个查询的中间的map/reduce任务输出是否要被压缩，默认false，</span><br><span class="line"></span><br><span class="line">hive.jar.path：当使用独立的jvm提交作业时，hive_cli.jar所在的位置，无默认值；</span><br><span class="line"></span><br><span class="line">hive.aux.jars.path：当用户自定义了UDF或者SerDe，这些插件的jar都要放到这个目录下，无默认值；</span><br><span class="line"></span><br><span class="line">hive.partition.pruning：在编译器发现一个query语句中使用分区表然而未提供任何分区谓词做查询时，抛出一个错误从而保护分区表，默认是nonstrict；（待读源码后细化，网上资料极少）</span><br><span class="line"></span><br><span class="line">hive.map.aggr：map端聚合是否开启，默认开启；</span><br><span class="line"></span><br><span class="line">hive.join.emit.interval：在发出join结果之前对join最右操作缓存多少行的设定，默认1000；hive jira里有个对该值设置太小的bugfix；</span><br><span class="line"></span><br><span class="line">hive.map.aggr.hash.percentmemory：map端聚合时hash表所占用的内存比例，默认0.5，这个在map端聚合开启后使用，</span><br><span class="line"></span><br><span class="line">hive.default.fileformat：CREATE TABLE语句的默认文件格式，默认TextFile，其他可选的有SequenceFile、RCFile还有Orc；</span><br><span class="line"></span><br><span class="line">hive.merge.mapfiles：在只有map的作业结束时合并小文件，默认开启true；</span><br><span class="line"></span><br><span class="line">hive.merge.mapredfiles：在一个map/reduce作业结束后合并小文件，默认不开启false；</span><br><span class="line"></span><br><span class="line">hive.merge.size.per.task：作业结束时合并文件的大小，默认256MB；</span><br><span class="line"></span><br><span class="line">hive.merge.smallfiles.avgsize：在作业输出文件小于该值时，起一个额外的map/reduce作业将小文件合并为大文件，小文件的基本阈值，设置大点可以减少小文件个数，需要mapfiles和mapredfiles为true，默认值是16MB；</span><br><span class="line"></span><br><span class="line">mapred.reduce.tasks：每个作业的reduce任务数，默认是hadoop client的配置1个；</span><br><span class="line"></span><br><span class="line">hive.exec.reducers.bytes.per.reducer：每个reducer的大小，默认是1G，输入文件如果是10G，那么就会起10个reducer；</span><br><span class="line"></span><br><span class="line">hive.exec.reducers.max：reducer的最大个数，如果在mapred.reduce.tasks设置为负值，那么hive将取该值作为reducers的最大可能值。当然还要依赖（输入文件大小/hive.exec.reducers.bytes.per.reducer）所得出的大小，取其小值作为reducer的个数，hive默认是999；</span><br><span class="line"></span><br><span class="line">hive.fileformat.check：加载数据文件时是否校验文件格式，默认是true；</span><br><span class="line"></span><br><span class="line">hive.groupby.skewindata：group by操作是否允许数据倾斜，默认是false，当设置为true时，执行计划会生成两个map/reduce作业，第一个MR中会将map的结果随机分布到reduce中，达到负载均衡的目的来解决数据倾斜，</span><br><span class="line"></span><br><span class="line">hive.groupby.mapaggr.checkinterval：map端做聚合时，group by 的key所允许的数据行数，超过该值则进行分拆，默认是100000；</span><br><span class="line"></span><br><span class="line">hive.mapred.local.mem：本地模式时，map/reduce的内存使用量，默认是0，就是无限制；</span><br><span class="line"></span><br><span class="line">hive.mapjoin.followby.map.aggr.hash.percentmemory：map端聚合时hash表的内存占比，该设置约束group by在map join后进行，否则使用hive.map.aggr.hash.percentmemory来确认内存占比，默认值0.3；</span><br><span class="line"></span><br><span class="line">hive.map.aggr.hash.force.flush.memeory.threshold：map端聚合时hash表的最大可用内存，如果超过该值则进行flush数据，默认是0.9；</span><br><span class="line"></span><br><span class="line">hive.map.aggr.hash.min.reduction：如果hash表的容量与输入行数之比超过这个数，那么map端的hash聚合将被关闭，默认是0.5，设置为1可以保证hash聚合永不被关闭；</span><br><span class="line"></span><br><span class="line">hive.optimize.groupby：在做分区和表查询时是否做分桶group by，默认开启true；</span><br><span class="line"></span><br><span class="line">hive.multigroupby.singlemr：将多个group by产出为一个单一map/reduce任务计划，当然约束前提是group by有相同的key，默认是false；</span><br><span class="line"></span><br><span class="line">hive.optimize.cp：列裁剪，默认开启true，在做查询时只读取用到的列，这个是个有用的优化；</span><br><span class="line"></span><br><span class="line">hive.optimize.index.filter：自动使用索引，默认不开启false；</span><br><span class="line"></span><br><span class="line">hive.optimize.index.groupby：是否使用聚集索引优化group-by查询，默认关闭false；</span><br><span class="line"></span><br><span class="line">hive.optimize.ppd：是否支持谓词下推，默认开启；所谓谓词下推，将外层查询块的 WHERE 子句中的谓词移入所包含的较低层查询块（例如视图），从而能够提早进行数据过滤以及有可能更好地利用索引。</span><br><span class="line"></span><br><span class="line">hive.optimize.ppd.storage：谓词下推开启时，谓词是否下推到存储handler，默认开启，在谓词下推关闭时不起作用；</span><br><span class="line"></span><br><span class="line">hive.ppd.recognizetransivity：在等值join条件下是否产地重复的谓词过滤器，默认开启；</span><br><span class="line"></span><br><span class="line">hive.join.cache.size：在做表join时缓存在内存中的行数，默认25000；</span><br><span class="line"></span><br><span class="line">hive.mapjoin.bucket.cache.size：mapjoin时内存cache的每个key要存储多少个value，默认100；</span><br><span class="line"></span><br><span class="line">hive.optimize.skewjoin：是否开启数据倾斜的join优化，默认不开启false；</span><br><span class="line"></span><br><span class="line">hive.skewjoin.key：判断数据倾斜的阈值，如果在join中发现同样的key超过该值则认为是该key是倾斜的join key，默认是100000；</span><br><span class="line"></span><br><span class="line">hive.skewjoin.mapjoin.map.tasks：在数据倾斜join时map join的map数控制，默认是10000；</span><br><span class="line"></span><br><span class="line">hive.skewjoin.mapjoin.min.split：数据倾斜join时map join的map任务的最小split大小，默认是33554432，该参数要结合上面的参数共同使用来进行细粒度的控制；</span><br><span class="line"></span><br><span class="line">hive.mapred.mode：hive操作执行时的模式，默认是nonstrict非严格模式，如果是strict模式，很多有风险的查询会被禁止运行，比如笛卡尔积的join和动态分区；</span><br><span class="line"></span><br><span class="line">hive.exec.script.maxerrsize：一个map/reduce任务允许打印到标准错误里的最大字节数，为了防止脚本把分区日志填满，默认是100000；</span><br><span class="line"></span><br><span class="line">hive.exec.script.allow.partial.consumption：hive是否允许脚本不从标准输入中读取任何内容就成功退出，默认关闭false；</span><br><span class="line"></span><br><span class="line">hive.script.operator.id.env.var：在用户使用transform函数做自定义map/reduce时，存储唯一的脚本标识的环境变量的名字，默认HIVE_SCRIPT_OPERATOR_ID；</span><br><span class="line"></span><br><span class="line">hive.exec.compress.output：控制hive的查询结果输出是否进行压缩，压缩方式在hadoop的mapred.output.compress中配置，默认不压缩false；</span><br><span class="line"></span><br><span class="line">hive.exec.compress.intermediate：控制hive的查询中间结果是否进行压缩，同上条配置，默认不压缩false；</span><br><span class="line"></span><br><span class="line">hive.exec.parallel：hive的执行job是否并行执行，默认不开启false，在很多操作如join时，子查询之间并无关联可独立运行，这种情况下开启并行运算可以大大加速；</span><br><span class="line"></span><br><span class="line">hvie.exec.parallel.thread.number：并行运算开启时，允许多少作业同时计算，默认是8；</span><br><span class="line"></span><br><span class="line">hive.exec.rowoffset：是否提供行偏移量的虚拟列，默认是false不提供，Hive有两个虚拟列:一个是INPUT__FILE__NAME,表示输入文件的路径，另外一个是BLOCK__OFFSET__INSIDE__FILE，表示记录在文件中的块偏移量，这对排查出现不符合预期或者null结果的查询是很有帮助的；</span><br><span class="line"></span><br><span class="line">hive.task.progress：控制hive是否在执行过程中周期性的更新任务进度计数器，开启这个配置可以帮助job tracker更好的监控任务的执行情况，但是会带来一定的性能损耗，当动态分区标志hive.exec.dynamic.partition开启时，本配置自动开启；</span><br><span class="line"></span><br><span class="line">hive.exec.pre.hooks：执行前置条件，一个用逗号分隔开的实现了org.apache.hadoop.hive.ql.hooks.ExecuteWithHookContext接口的java class列表，配置了该配置后，每个hive任务执行前都要执行这个执行前钩子，默认是空；</span><br><span class="line"></span><br><span class="line">hive.exec.post.hooks：同上，执行后钩子，默认是空；</span><br><span class="line"></span><br><span class="line">hive.exec.failure.hooks：同上，异常时钩子，在程序发生异常时执行，默认是空；</span><br><span class="line"></span><br><span class="line">hive.mergejob.maponly：试图生成一个只有map的任务去做merge，前提是支持CombineHiveInputFormat，默认开启true；</span><br><span class="line"></span><br><span class="line">hive.mapjoin.smalltable.filesize：输入表文件的mapjoin阈值，如果输入文件的大小小于该值，则试图将普通join转化为mapjoin，默认25MB；</span><br><span class="line"></span><br><span class="line">hive.mapjoin.localtask.max.memory.usage：mapjoin本地任务执行时hash表容纳key/value的最大量，超过这个值的话本地任务会自动退出，默认是0.9；</span><br><span class="line"></span><br><span class="line">hive.mapjoin.followby.gby.localtask.max.memory.usage：类似上面，只不过是如果mapjoin后有一个group by的话，该配置控制类似这样的query的本地内存容量上限，默认是0.55；</span><br><span class="line"></span><br><span class="line">hive.mapjoin.check.memory.rows：在运算了多少行后执行内存使用量检查，默认100000；</span><br><span class="line"></span><br><span class="line">hive.heartbeat.interval：发送心跳的时间间隔，在mapjoin和filter操作中使用，默认1000；</span><br><span class="line"></span><br><span class="line">hive.auto.convert.join：根据输入文件的大小决定是否将普通join转换为mapjoin的一种优化，默认不开启false；</span><br><span class="line"></span><br><span class="line">hive.script.auto.progress：hive的transform/map/reduce脚本执行时是否自动的将进度信息发送给TaskTracker来避免任务没有响应被误杀，本来是当脚本输出到标准错误时，发送进度信息，但是开启该项后，输出到标准错误也不会导致信息发送，因此有可能会造成脚本有死循环产生，但是TaskTracker却没有检查到从而一直循环下去；</span><br><span class="line"></span><br><span class="line">hive.script.serde：用户脚本转换输入到输出时的SerDe约束，默认是org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe；</span><br><span class="line"></span><br><span class="line">hive.script.recordreader：从脚本读数据的时候的默认reader，默认是org.apache.hadoop.hive.ql.exec.TextRecordReader；</span><br><span class="line"></span><br><span class="line">hive.script.recordwriter：写数据到脚本时的默认writer，默认org.apache.hadoop.hive.ql.exec.TextRecordWriter；</span><br><span class="line"></span><br><span class="line">hive.input.format：输入格式，默认是org.apache.hadoop.hive.ql.io.CombineHiveInputFormat，如果出现问题，可以改用org.apache.hadoop.hive.ql.io.HiveInputFormat；</span><br><span class="line"></span><br><span class="line">hive.udtf.auto.progress：UDTF执行时hive是否发送进度信息到TaskTracker，默认是false；</span><br><span class="line"></span><br><span class="line">hive.mapred.reduce.tasks.speculative.execution：reduce任务推测执行是否开启，默认是true；</span><br><span class="line"></span><br><span class="line">hive.exec.counters.pull.interval：运行中job轮询JobTracker的时间间隔，设置小会影响JobTracker的load，设置大可能看不出运行任务的信息，要去平衡，默认是1000；</span><br><span class="line"></span><br><span class="line">hive.enforce.bucketing：数据分桶是否被强制执行，默认false，如果开启，则写入table数据时会启动分桶，</span><br><span class="line"></span><br><span class="line">hive.enforce.sorting：开启强制排序时，插数据到表中会进行强制排序，默认false；</span><br><span class="line"></span><br><span class="line">hive.optimize.reducededuplication：如果数据已经根据相同的key做好聚合，那么去除掉多余的map/reduce作业，此配置是文档的推荐配置，建议打开，默认是true；</span><br><span class="line"></span><br><span class="line">hive.exec.dynamic.partition：在DML/DDL中是否支持动态分区，默认false；</span><br><span class="line"></span><br><span class="line">hive.exec.dynamic.partition.mode：默认strict，在strict模式下，动态分区的使用必须在一个静态分区确认的情况下，其他分区可以是动态；</span><br><span class="line"></span><br><span class="line">hive.exec.max.dynamic.partitions：动态分区的上限，默认1000；</span><br><span class="line"></span><br><span class="line">hive.exec.max.dynamic.partitions.pernode：每个mapper/reducer节点可以创建的最大动态分区数，默认100；</span><br><span class="line"></span><br><span class="line">hive.exec.max.created.files：一个mapreduce作业能创建的HDFS文件最大数，默认是100000；</span><br><span class="line"></span><br><span class="line">hive.exec.default.partition.name：当动态分区启用时，如果数据列里包含null或者空字符串的话，数据会被插入到这个分区，默认名字是HIVE_DEFAULT_PARTITION；</span><br><span class="line"></span><br><span class="line">hive.fetch.output.serde：FetchTask序列化fetch输出时需要的SerDe，默认是org.apache.hadoop.hive.serde2.DelimitedJSONSerDe;</span><br><span class="line"></span><br><span class="line">hive.exec.mode.local.auto：是否由hive决定自动在local模式下运行，默认是false，</span><br><span class="line"></span><br><span class="line">hive.exec.drop.ignorenoneexistent：在drop表或者视图时如果发现表或视图不存在，是否报错，默认是true；</span><br><span class="line"></span><br><span class="line">hive.exec.show.job.failure.debug.info：在作业失败时是否提供一个任务debug信息，默认true；</span><br><span class="line"></span><br><span class="line">hive.auto.progress.timeout：运行自动progressor的时间间隔，默认是0等价于forever；</span><br><span class="line"></span><br><span class="line">hive.table.parameters.default：新建表的属性字段默认值，默认是empty空；</span><br><span class="line"></span><br><span class="line">hive.variable.substitute：是否支持变量替换，如果开启的话，支持语法如varvar&#123;system:var&#125;和$&#123;env.var&#125;，默认是true；</span><br><span class="line"></span><br><span class="line">hive.error.on.empty.partition：在遇到结果为空的动态分区时是否报错，默认是false；</span><br><span class="line"></span><br><span class="line">hive.exim.uri.scheme.whitelist：在导入导出数据时提供的一个白名单列表，列表项之间由逗号分隔，默认hdfs,pfile；</span><br><span class="line"></span><br><span class="line">hive.limit.row.max.size：字面意思理解就是在使用limit做数据的子集查询时保证的最小行数据量，默认是100000；</span><br><span class="line"></span><br><span class="line">hive.limit.optimize.limit.file：使用简单limit查询数据子集时，可抽样的最大文件数，默认是10；</span><br><span class="line"></span><br><span class="line">hive.limit.optimize.enable：使用简单limit抽样数据时是否开启优化选项，默认是false，关于limit的优化问题，在hive programming书中解释的是这个feature有drawback，对于抽样的不确定性给出了风险提示；</span><br><span class="line"></span><br><span class="line">hive.limit.optimize.fetch.max：使用简单limit抽样数据允许的最大行数，默认50000，查询query受限，insert不受影响；</span><br><span class="line"></span><br><span class="line">hive.rework.mapredwork：是否重做mapreduce，默认是false；</span><br><span class="line"></span><br><span class="line">hive.sample.seednumber：用来区分抽样的数字，默认是0；</span><br><span class="line"></span><br><span class="line">hive.io.exception.handlers：io异常处理handler类列表，默认是空，当record reader发生io异常时，由这些handler来处理异常；</span><br><span class="line"></span><br><span class="line">hive.autogen.columnalias.prefix.label：当在执行中自动产生列别名的前缀，当类似count这样的聚合函数起作用时，如果不明确指出count(a) as xxx的话，那么默认会从列的位置的数字开始算起添加，比如第一个count的结果会冠以列名_c0，接下来依次类推，默认值是_c，数据开发过程中应该很多人都看到过这个别名；</span><br><span class="line"></span><br><span class="line">hive.autogen.columnalias.prefix.includefuncname：在自动生成列别名时是否带函数的名字，默认是false；</span><br><span class="line"></span><br><span class="line">hive.exec.perf.logger：负责记录客户端性能指标的日志类名，必须是org.apache.hadoop.hive.ql.log.PerfLogger的子类，默认是org.apache.hadoop.hive.ql.log.PerfLogger；</span><br><span class="line"></span><br><span class="line">hive.start.cleanup.scratchdir：当启动hive服务时是否清空hive的scratch目录，默认是false；</span><br><span class="line"></span><br><span class="line">hive.output.file.extension：输出文件扩展名，默认是空；</span><br><span class="line"></span><br><span class="line">hive.insert.into.multilevel.dirs：是否插入到多级目录，默认是false；</span><br><span class="line"></span><br><span class="line">hive.files.umask.value：hive创建文件夹时的dfs.umask值，默认是0002；</span><br><span class="line"></span><br><span class="line">hive.metastore.local：控制hive是否连接一个远程metastore服务器还是开启一个本地客户端jvm，默认是true，Hive0.10已经取消了该配置项；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.ConnectionURL：JDBC连接字符串，默认jdbc:derby:;databaseName=metastore_db;create=true；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.ConnectionDriverName：JDBC的driver，默认org.apache.derby.jdbc.EmbeddedDriver；</span><br><span class="line"></span><br><span class="line">javax.jdo.PersisteneManagerFactoryClass：实现JDO PersistenceManagerFactory的类名，默认org.datanucleus.jdo.JDOPersistenceManagerFactory；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.DetachAllOnCommit：事务提交后detach所有提交的对象，默认是true；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.NonTransactionalRead：是否允许非事务的读，默认是true；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.ConnectionUserName：username，默认APP；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.ConnectionPassword：password，默认mine；</span><br><span class="line"></span><br><span class="line">javax.jdo.option.Multithreaded：是否支持并发访问metastore，默认是true；</span><br><span class="line"></span><br><span class="line">datanucleus.connectionPoolingType：使用连接池来访问JDBC metastore，默认是DBCP；</span><br><span class="line"></span><br><span class="line">datanucleus.validateTables：检查是否存在表的schema，默认是false；</span><br><span class="line"></span><br><span class="line">datanucleus.validateColumns：检查是否存在列的schema，默认false；</span><br><span class="line"></span><br><span class="line">datanucleus.validateConstraints：检查是否存在constraint的schema，默认false；</span><br><span class="line"></span><br><span class="line">datanucleus.stroeManagerType：元数据存储类型，默认rdbms；</span><br><span class="line"></span><br><span class="line">datanucleus.autoCreateSchema：在不存在时是否自动创建必要的schema，默认是true；</span><br><span class="line"></span><br><span class="line">datanucleus.aotuStartMechanismMode：如果元数据表不正确，抛出异常，默认是checked；</span><br><span class="line"></span><br><span class="line">datanucleus.transactionIsolation：默认的事务隔离级别，默认是read-committed；</span><br><span class="line"></span><br><span class="line">datanucleus.cache.level2：使用二级缓存，默认是false；</span><br><span class="line"></span><br><span class="line">datanucleus.cache.level2.type：二级缓存的类型，有两种，SOFT:软引用，WEAK:弱引用，默认是SOFT；</span><br><span class="line"></span><br><span class="line">datanucleus.identifierFactory：id工厂生产表和列名的名字，默认是datanucleus；</span><br><span class="line"></span><br><span class="line">datanucleus.plugin.pluginRegistryBundleCheck：当plugin被发现并且重复时的行为，默认是LOG；</span><br><span class="line"></span><br><span class="line">hive.metastroe.warehouse.dir：数据仓库的位置，默认是/user/hive/warehouse；</span><br><span class="line"></span><br><span class="line">hive.metastore.execute.setugi：非安全模式，设置为true会令metastore以客户端的用户和组权限执行DFS操作，默认是false，这个属性需要服务端和客户端同时设置；</span><br><span class="line"></span><br><span class="line">hive.metastore.event.listeners：metastore的事件监听器列表，逗号隔开，默认是空；</span><br><span class="line"></span><br><span class="line">hive.metastore.partition.inherit.table.properties：当新建分区时自动继承的key列表，默认是空；</span><br><span class="line"></span><br><span class="line">hive.metastore.end.function.listeners：metastore函数执行结束时的监听器列表，默认是空；</span><br><span class="line"></span><br><span class="line">hive.metastore.event.expiry.duration：事件表中事件的过期时间，默认是0；</span><br><span class="line"></span><br><span class="line">hive.metastore.event.clean.freq：metastore中清理过期事件的定时器的运行周期，默认是0；</span><br><span class="line"></span><br><span class="line">hive.metastore.connect.retries：创建metastore连接时的重试次数，默认是5；</span><br><span class="line"></span><br><span class="line">hive.metastore.client.connect.retry.delay：客户端在连续的重试连接等待的时间，默认1；</span><br><span class="line"></span><br><span class="line">hive.metastore.client.socket.timeout：客户端socket超时时间，默认20秒；</span><br><span class="line"></span><br><span class="line">hive.metastore.rawstore.impl：原始metastore的存储实现类，默认是org.apache.hadoop.hive.metastore.ObjectStore；</span><br><span class="line"></span><br><span class="line">hive.metastore.batch.retrieve.max：在一个batch获取中，能从metastore里取出的最大记录数，默认是300；</span><br><span class="line"></span><br><span class="line">hive.metastore.ds.connection.url.hook：查找JDO连接url时hook的名字，默认是javax.jdo.option.ConnectionURL；</span><br><span class="line"></span><br><span class="line">hive.metastore.ds.retry.attempts：当出现连接错误时重试连接的次数，默认是1次；</span><br><span class="line"></span><br><span class="line">hive.metastore.ds.retry.interval：metastore重试连接的间隔时间，默认1000毫秒；</span><br><span class="line"></span><br><span class="line">hive.metastore.server.min.threads：在thrift服务池中最小的工作线程数，默认是200；</span><br><span class="line"></span><br><span class="line">hive.metastore.server.max.threads：最大线程数，默认是100000；</span><br><span class="line"></span><br><span class="line">hive.metastore.server.tcp.keepalive：metastore的server是否开启长连接，长连可以预防半连接的积累，默认是true；</span><br><span class="line"></span><br><span class="line">hive.metastore.sasl.enabled：metastore thrift接口的安全策略，开启则用SASL加密接口，客户端必须要用Kerberos机制鉴权，默认是不开启false；</span><br><span class="line"></span><br><span class="line">hive.metastore.kerberos.keytab.file：在开启sasl后kerberos的keytab文件存放路径，默认是空；</span><br><span class="line"></span><br><span class="line">hive.metastore.kerberos.principal：kerberos的principal，_HOST部分会动态替换，默认是hive-metastore/_HOST@EXAMPLE.COM；</span><br><span class="line"></span><br><span class="line">hive.metastore.cache.pinobjtypes：在cache中支持的metastore的对象类型，由逗号分隔，默认是Table,StorageDescriptor,SerDeInfo,Partition,Database,Type,FieldSchema,Order；</span><br><span class="line"></span><br><span class="line">hive.metastore.authorization.storage.checks：在做类似drop partition操作时，metastore是否要认证权限，默认是false；</span><br><span class="line"></span><br><span class="line">hive.metastore.schema.verification：强制metastore的schema一致性，开启的话会校验在metastore中存储的信息的版本和hive的jar包中的版本一致性，并且关闭自动schema迁移，用户必须手动的升级hive并且迁移schema，关闭的话只会在版本不一致时给出警告，默认是false不开启；</span><br><span class="line"></span><br><span class="line">hive.index.compact.file.ignore.hdfs：在索引文件中存储的hdfs地址将在运行时被忽略，如果开启的话；如果数据被迁移，那么索引文件依然可用，默认是false；</span><br><span class="line"></span><br><span class="line">hive.optimize.index.filter.compact.minsize：压缩索引自动应用的最小输入大小，默认是5368709120；</span><br><span class="line"></span><br><span class="line">hive.optimize.index.filter.compact.maxsize：同上，相反含义，如果是负值代表正无穷，默认是-1；</span><br><span class="line"></span><br><span class="line">hive.index.compact.query.max.size：一个使用压缩索引做的查询能取到的最大数据量，默认是10737418240 个byte；负值代表无穷大；</span><br><span class="line"></span><br><span class="line">hive.index.compact.query.max.entries：使用压缩索引查询时能读到的最大索引项数，默认是10000000；负值代表无穷大；</span><br><span class="line"></span><br><span class="line">hive.index.compact.binary.search：在索引表中是否开启二分搜索进行索引项查询，默认是true；</span><br><span class="line"></span><br><span class="line">hive.exec.concatenate.check.index：如果设置为true，那么在做ALTER TABLE tbl_name CONCATENATE on a table/partition（有索引） 操作时，抛出错误；可以帮助用户避免index的删除和重建；</span><br><span class="line"></span><br><span class="line">hive.stats.dbclass：存储hive临时统计信息的数据库，默认是jdbc:derby；</span><br><span class="line"></span><br><span class="line">hive.stats.autogather：在insert overwrite命令时自动收集统计信息，默认开启true；</span><br><span class="line"></span><br><span class="line">hive.stats.jdbcdriver：数据库临时存储hive统计信息的jdbc驱动；</span><br><span class="line"></span><br><span class="line">hive.stats.dbconnectionstring：临时统计信息数据库连接串，默认jdbc:derby:databaseName=TempStatsStore;create=true；</span><br><span class="line"></span><br><span class="line">hive.stats.defaults.publisher：如果dbclass不是jdbc或者hbase，那么使用这个作为默认发布，必须实现StatsPublisher接口，默认是空；</span><br><span class="line"></span><br><span class="line">hive.stats.defaults.aggregator：如果dbclass不是jdbc或者hbase，那么使用该类做聚集，要求实现StatsAggregator接口，默认是空；</span><br><span class="line"></span><br><span class="line">hive.stats.jdbc.timeout：jdbc连接超时配置，默认30秒；</span><br><span class="line"></span><br><span class="line">hive.stats.retries.max：当统计发布合聚集在更新数据库时出现异常时最大的重试次数，默认是0，不重试；</span><br><span class="line"></span><br><span class="line">hive.stats.retries.wait：重试次数之间的等待窗口，默认是3000毫秒；</span><br><span class="line"></span><br><span class="line">hive.client.stats.publishers：做count的job的统计发布类列表，由逗号隔开，默认是空；必须实现org.apache.hadoop.hive.ql.stats.ClientStatsPublisher接口；</span><br><span class="line"></span><br><span class="line">hive.client.stats.counters：没什么用~~~</span><br><span class="line"></span><br><span class="line">hive.security.authorization.enabled：hive客户端是否认证，默认是false；</span><br><span class="line"></span><br><span class="line">hive.security.authorization.manager：hive客户端认证的管理类，默认是org.apache.hadoop.hive.ql.security.authorization.DefaultHiveAuthorizationProvider；用户定义的要实现org.apache.hadoop.hive.ql.security.authorization.HiveAuthorizationProvider；</span><br><span class="line"></span><br><span class="line">hive.security.authenticator.manager：hive客户端授权的管理类，默认是org.apache.hadoop.hive.ql.security.HadoopDefaultAuthenticator；用户定义的需要实现org.apache.hadoop.hive.ql.security.HiveAuthenticatorProvider；</span><br><span class="line"></span><br><span class="line">hive.security.authorization.createtable.user.grants：当表创建时自动授权给用户，默认是空；</span><br><span class="line"></span><br><span class="line">hive.security.authorization.createtable.group.grants：同上，自动授权给组，默认是空；</span><br><span class="line"></span><br><span class="line">hive.security.authorization.createtable.role.grants：同上，自动授权给角色，默认是空；</span><br><span class="line"></span><br><span class="line">hive.security.authorization.createtable.owner.grants：同上，自动授权给owner，默认是空；</span><br><span class="line"></span><br><span class="line">hive.security.metastore.authorization.manager：metastore的认证管理类，默认是org.apache.hadoop.hive.ql.security.authorization.DefaultHiveMetastoreAuthorizationProvider；用户定义的必须实现org.apache.hadoop.hive.ql.security.authorization.HiveMetastoreAuthorizationProvider接口；接口参数要包含org.apache.hadoop.hive.ql.security.authorization.StorageBasedAuthorizationProvider接口；使用HDFS的权限控制认证而不是hive的基于grant的方式；</span><br><span class="line"></span><br><span class="line">hive.security.metastore.authenticator.manager：metastore端的授权管理类，默认是org.apache.hadoop.hive.ql.security.HadoopDefaultMetastoreAuthenticator，自定义的必须实现org.apache.hadoop.hive.ql.security.HiveAuthenticatorProvider接口；</span><br><span class="line"></span><br><span class="line">hive.metastore.pre.event.listeners：在metastore做数据库任何操作前执行的事件监听类列表；</span><br><span class="line"></span><br><span class="line">fs.har.impl：访问Hadoop Archives的实现类，低于hadoop 0.20版本的都不兼容，默认是org.apache.hadoop.hive.shims.HiveHarFileSystem；</span><br><span class="line"></span><br><span class="line">hive.archive.enabled：是否允许归档操作，默认是false；</span><br><span class="line"></span><br><span class="line">hive.archive.har.parentdir.settable：在创建HAR文件时必须要有父目录，需要手动设置，在新的hadoop版本会支持，默认是false；</span><br><span class="line"></span><br><span class="line">hive.support.concurrency：hive是否支持并发，默认是false，支持读写锁的话，必须要起zookeeper；</span><br><span class="line"></span><br><span class="line">hive.lock.mapred.only.operation：控制是否在查询时加锁，默认是false；</span><br><span class="line"></span><br><span class="line">hive.lock.numretries：获取锁时尝试的重试次数，默认是100；</span><br><span class="line"></span><br><span class="line">hive.lock.sleep.between.retries：在重试间隔的睡眠时间，默认60秒；</span><br><span class="line"></span><br><span class="line">hive.zookeeper.quorum：zk地址列表，默认是空；</span><br><span class="line"></span><br><span class="line">hive.zookeeper.client.port：zk服务器的连接端口，默认是2181；</span><br><span class="line"></span><br><span class="line">hive.zookeeper.session.timeout：zk客户端的session超时时间，默认是600000；</span><br><span class="line"></span><br><span class="line">hive.zookeeper.namespace：在所有zk节点创建后的父节点，默认是hive_zookeeper_namespace；</span><br><span class="line"></span><br><span class="line">hive.zookeeper.clean.extra.nodes：在session结束时清除所有额外node；</span><br><span class="line"></span><br><span class="line">hive.cluster.delegation.token.store.class：代理token的存储实现类，默认是org.apache.hadoop.hive.thrift.MemoryTokenStore，可以设置为org.apache.hadoop.hive.thrift.ZooKeeperTokenStore来做负载均衡集群；</span><br><span class="line"></span><br><span class="line">hive.cluster.delegation.token.store.zookeeper.connectString：zk的token存储连接串，默认是localhost:2181；</span><br><span class="line"></span><br><span class="line">hive.cluster.delegation.token.store.zookeeper.znode：token存储的节点跟路径，默认是/hive/cluster/delegation；</span><br><span class="line"></span><br><span class="line">hive.cluster.delegation.token.store.zookeeper.acl：token存储的ACL，默认是sasl:hive/host1@example.com:cdrwa,sasl:hive/host2@example.com:cdrwa；</span><br><span class="line"></span><br><span class="line">hive.use.input.primary.region：从一张input表创建表时，创建这个表到input表的主region，默认是true；</span><br><span class="line"></span><br><span class="line">hive.default.region.name：默认region的名字，默认是default；</span><br><span class="line"></span><br><span class="line">hive.region.properties：region的默认的文件系统和jobtracker，默认是空；</span><br><span class="line"></span><br><span class="line">hive.cli.print.header：查询输出时是否打印名字和列，默认是false；</span><br><span class="line"></span><br><span class="line">hive.cli.print.current.db：hive的提示里是否包含当前的db，默认是false；</span><br><span class="line"></span><br><span class="line">hive.hbase.wal.enabled：写入hbase时是否强制写wal日志，默认是true；</span><br><span class="line"></span><br><span class="line">hive.hwi.war.file：hive在web接口是的war文件的路径，默认是lib/hive-hwi-xxxx(version).war；</span><br><span class="line"></span><br><span class="line">hive.hwi.listen.host：hwi监听的host地址，默认是0.0.0.0；</span><br><span class="line"></span><br><span class="line">hive.hwi.listen.port：hwi监听的端口，默认是9999；</span><br><span class="line"></span><br><span class="line">hive.test.mode：hive是否运行在测试模式，默认是false；</span><br><span class="line"></span><br><span class="line">hive.test.mode.prefix：在测试模式运行时，表的前缀字符串，默认是test_；</span><br><span class="line"></span><br><span class="line">hive.test.mode.samplefreq：如果hive在测试模式运行，并且表未分桶，抽样频率是多少，默认是32；</span><br><span class="line"></span><br><span class="line">hive.test.mode.nosamplelist：在测试模式运行时不进行抽样的表列表，默认是空；</span><br></pre></td></tr></table></figure>
<h2 id="12、HIVE_数据倾斜的可能原因有哪些？主要解决方法有哪些？">12、HIVE 数据倾斜的可能原因有哪些？主要解决方法有哪些？</h2><h3 id="数据倾斜的原因">数据倾斜的原因</h3><ul>
<li><p>操作<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15311306228352.jpg" alt=""></p>
</li>
<li><p>原因</p>
<ol>
<li>key分布不均匀</li>
<li>业务数据本身的特性</li>
<li>建表时考虑不周</li>
<li>某些SQL语句本身就有数据倾斜</li>
</ol>
</li>
<li><p>表现<br>  任务进度长时间维持在99%（或100%），查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大。</p>
</li>
</ul>
<p>单一reduce的记录数与平均记录数差异过大，通常可能达到3倍甚至更多。 最长时长远大于平均时长。</p>
<h3 id="数据倾斜的解决方案">数据倾斜的解决方案</h3><ul>
<li>参数调节</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive.map.aggr=true</span><br><span class="line"></span><br><span class="line">Map 端部分聚合，相当于Combiner</span><br><span class="line"></span><br><span class="line">hive.groupby.skewindata=true</span><br><span class="line"></span><br><span class="line">有数据倾斜的时候进行负载均衡，当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>SQL语句调节</p>
<ul>
<li><p>如何Join：</p>
<p>关于驱动表的选取，选用join key分布最均匀的表作为驱动表</p>
<p>做好列裁剪和filter操作，以达到两表做join的时候，数据量相对变小的效果。</p>
</li>
<li><p>大小表Join：</p>
<p>使用map join让小的维度表（1000条以下的记录条数） 先进内存。在map端完成reduce.</p>
</li>
<li><p>大表Join大表：</p>
<p>把空值的key变成一个字符串加上随机数，把倾斜的数据分到不同的reduce上，由于null值关联不上，处理后并不影响最终结果。</p>
</li>
<li><p>count distinct大量相同特殊值</p>
<p>count distinct时，将值为空的情况单独处理，如果是计算count distinct，可以不用处理，直接过滤，在最后结果中加1。如果还有其他计算，需要进行group by，可以先将值为空的记录单独处理，再和其他计算结果进行union。</p>
</li>
<li><p>group by维度过小：</p>
<p>采用sum() group by的方式来替换count(distinct)完成计算。</p>
</li>
<li><p>特殊情况特殊处理：</p>
<p>在业务逻辑优化效果的不大情况下，有些时候是可以将倾斜的数据单独拿出来处理。最后union回去。</p>
</li>
</ul>
</li>
</ul>
<h3 id="典型的业务场景">典型的业务场景</h3><ul>
<li>空值产生的数据倾斜</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">场景：如日志中，常会有信息丢失的问题，比如日志中的 user_id，如果取其中的 user_id 和 用户表中的user_id 关联，会碰到数据倾斜的问题。</span><br><span class="line"></span><br><span class="line">解决方法1： user_id为空的不参与关联（红色字体为修改后）</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">select * from log a</span><br><span class="line">  join users b</span><br><span class="line">  on a.user_id is not null</span><br><span class="line">  and a.user_id = b.user_id</span><br><span class="line">union all</span><br><span class="line">select * from log a</span><br><span class="line">  where a.user_id is null;</span><br><span class="line">复制代码</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">解决方法2 ：赋与空值分新的key值</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">  from log a</span><br><span class="line">  left outer join users b</span><br><span class="line">  on case when a.user_id is null then concat(‘hive’,rand() ) else a.user_id end = b.user_id;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">结论：方法2比方法1效率更好，不但io少了，而且作业数也少了。解决方法1中 log读取两次，jobs是2。解决方法2 job数是1 。这个优化适合无效 id (比如 -99 , ’’, null 等) 产生的倾斜问题。把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的reduce上 ,解决数据倾斜问题。</span><br></pre></td></tr></table></figure>
<ul>
<li>不同数据类型关联产生数据倾斜</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景：用户表中user_id字段为int，log表中user_id字段既有string类型也有int类型。当按照user_id进行两个表的Join操作时，默认的Hash操作会按int型的id来进行分配，这样会导致所有string类型id的记录都分配到一个Reducer中。</span><br><span class="line"></span><br><span class="line">解决方法：把数字类型转换成字符串类型</span><br><span class="line"></span><br><span class="line">select * from users a</span><br><span class="line">  left outer join logs b</span><br><span class="line">  on a.usr_id = cast(b.user_id as string)</span><br></pre></td></tr></table></figure>
<ul>
<li>小表不小不大，怎么用 map join 解决倾斜问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用 map join 解决小表(记录数少)关联大表的数据倾斜问题，这个方法使用的频率非常高，但如果小表很大，大到map join会出现bug或异常，这时就需要特别的处理。 以下例子:</span><br><span class="line"></span><br><span class="line">select * from log a</span><br><span class="line">  left outer join users b</span><br><span class="line">  on a.user_id = b.user_id;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">users 表有 600w+ 的记录，把 users 分发到所有的 map 上也是个不小的开销，而且 map join 不支持这么大的小表。如果用普通的 join，又会碰到数据倾斜的问题。</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">select /*+mapjoin(x)*/* from log a</span><br><span class="line">  left outer join (</span><br><span class="line">    select  /*+mapjoin(c)*/d.*</span><br><span class="line">      from ( select distinct user_id from log ) c</span><br><span class="line">      join users d</span><br><span class="line">      on c.user_id = d.user_id</span><br><span class="line">    ) x</span><br><span class="line">  on a.user_id = b.user_id;</span><br><span class="line"> </span><br><span class="line">复制代码</span><br><span class="line">假如，log里user_id有上百万个，这就又回到原来map join问题。所幸，每日的会员uv不会太多，有交易的会员不会太多，有点击的会员不会太多，有佣金的会员不会太多等等。所以这个方法能解决很多场景下的数据倾斜问题。</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>使map的输出数据更均匀的分布到reduce中去，是我们的最终目标。由于Hash算法的局限性，按key Hash会或多或少的造成数据倾斜。大量经验表明数据倾斜的原因是人为的建表疏忽或业务逻辑可以规避的。在此给出较为通用的步骤：</p>
<p>1、采样log表，哪些user_id比较倾斜，得到一个结果表tmp1。由于对计算框架来说，所有的数据过来，他都是不知道数据分布情况的，所以采样是并不可少的。</p>
<p>2、数据的分布符合社会学统计规则，贫富不均。倾斜的key不会太多，就像一个社会的富人不多，奇特的人不多一样。所以tmp1记录数会很少。把tmp1和users做map join生成tmp2,把tmp2读到distribute file cache。这是一个map过程。</p>
<p>3、map读入users和log，假如记录来自log,则检查user_id是否在tmp2里，如果是，输出到本地文件a,否则生成<user_id,value>的key,value对，假如记录来自member,生成<user_id,value>的key,value对，进入reduce阶段。</user_id,value></user_id,value></p>
<p>4、最终把a文件，把Stage3 reduce阶段输出的文件合并起写到hdfs。</p>
<p>如果确认业务需要这样倾斜的逻辑，考虑以下的优化方案：</p>
<p>1、对于join，在判断小表不大于1G的情况下，使用map join</p>
<p>2、对于group by或distinct，设定 hive.groupby.skewindata=true</p>
<p>3、尽量使用上述的SQL语句调节进行优化</p>
<h2 id="13、数据仓库之数据架构设计图，及每个模块的主要作用？">13、数据仓库之数据架构设计图，及每个模块的主要作用？</h2><p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15311497429809.jpg" alt=""></p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15311497630184.jpg" alt=""></p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15311498682475.jpg" alt=""></p>
<h2 id="14、利用_HiveSQL_语句，创建如下两张表：">14、利用 HiveSQL 语句，创建如下两张表：</h2><p>创建员工基本信息表(EmployeeInfo)，字段包括(员工 ID，员工姓名，员工身份证号，性别，年龄，所属部门，岗位，入职公司时间，离职公司时间)，分区字段为入职公司时间，其行分隔符为”\n “，字段分隔符为”\t “。其中所属部门包括行政部、财务部、研发部、教学部，其对应岗位包括行政经理、行政专员、财务经理、财务专员、研发工程师、测试工程师、实施工程师、讲师、助教、班主任等，时间类型值如：2018-05-10 11:00:00</p>
<p>创建员工收入表(IncomeInfo)，字段包括(员工 ID，员工姓名，收入金额，收入所属</p>
<p>月份，收入类型，收入薪水的时间)，分区字段为发放薪水的时间，其中收入类型包括薪资、</p>
<p>奖金、公司福利、罚款四种情况 ; 时间类型值如：2018-05-10 11:00:00。</p>
<h2 id="15、用_HQL_实现，求公司每年的员工费用总支出各是多少，并按年份降序排列?">15、用 HQL 实现，求公司每年的员工费用总支出各是多少，并按年份降序排列?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sum(i_price), to_year(i_date) as &apos;c_year&apos; from IncomeInfo</span><br><span class="line"> group by c_year order by c_year desc;</span><br></pre></td></tr></table></figure>
<h2 id="16、用_HQL_实现，求各部门每年的员工费用总支出各是多少，并按年份降序，按部门的支出升序排列？">16、用 HQL 实现，求各部门每年的员工费用总支出各是多少，并按年份降序，按部门的支出升序排列？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sum(i_price), to_year(i_date) as &apos;c_year&apos; from IncomeInfo left join Emp on uid = uid</span><br><span class="line"> group by c_year order by c_year desc, eid asc;</span><br></pre></td></tr></table></figure>
<h2 id="17、用_HQL_实现，求各部门历史所有员工费用总支出各是多少，按总支出多少排名降序，遇到值相等情况，不留空位。">17、用 HQL 实现，求各部门历史所有员工费用总支出各是多少，按总支出多少排名降序，遇到值相等情况，不留空位。</h2><h2 id="18、用_HQL_实现，创建并生成员工薪资收入动态变化表，即员工_ID，员工姓名，员工本月薪资，本月薪资发放时间，员工上月薪资，上月薪资发放时间。分区字段为本月薪资发放时间。">18、用 HQL 实现，创建并生成员工薪资收入动态变化表，即员工 ID，员工姓名，员工本月薪资，本月薪资发放时间，员工上月薪资，上月薪资发放时间。分区字段为本月薪资发放时间。</h2><h2 id="19、用_HQL_实现，薪资涨幅方面，2018_年_5_月份谁的工资涨的最多，谁的涨幅最大？">19、用 HQL 实现，薪资涨幅方面，2018 年 5 月份谁的工资涨的最多，谁的涨幅最大？</h2><h2 id="20、对象二分查找的实现。">20、对象二分查找的实现。</h2><p>有学生基本信息类 Student，包括字段学号，姓名，班级，入学日期，共四个字段。其中学号是 SXXX 的格式，如 S001,S002 等。</p>
<p>现给定 6 个学生对象，如:<br>(S100,’张一”,”计科 1 班”,20180903),<br>(”S110”, ”张二”,”计科 1 班”,20180903),<br>(”S090”, ”张三”,”计科 2 班”,20180830),<br>(”S080”, ”张四”,”计科 2 班”,20180904),<br>(”S070”, ”张五”,”计科 2 班”,20180901),<br>(”S101”, ”张六”,”计科 1 班”,20180902),</p>
<p>求给定学号”S101”，通过对以上对象集进行二分查找后，确定是否在已给定的学生对象中，</p>
<p>若存在，则打印该学生信息，若不存在，则输出”查无此人”。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2018/07/05/2018-07-05-1/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/05/2018-07-05-1/" class="post-title-link" itemprop="url">常见数据结构与算法整理总结（下）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-05 16:09:10 / 修改时间：10:36:42" itemprop="dateCreated datePublished" datetime="2018-07-05T16:09:10+08:00">2018-07-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="常见数据结构与算法整理总结（下）">常见数据结构与算法整理总结（下）</h1><h2 id="一、概述">一、概述</h2><p>以前看到这样一句话，语言只是工具，算法才是程序设计的灵魂。的确，算法在计算机科学中的地位真的很重要，在很多大公司的笔试面试中，算法掌握程度的考察都占据了很大一部分。不管是为了面试还是自身编程能力的提升，花时间去研究常见的算法还是很有必要的。下面是自己对于算法这部分的学习总结。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307548459676.jpg" alt=""></p>
<blockquote>
<p>算法简介</p>
</blockquote>
<p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。对于同一个问题的解决，可能会存在着不同的算法，为了衡量一个算法的优劣，提出了空间复杂度与时间复杂度这两个概念。</p>
<blockquote>
<p>时间复杂度</p>
</blockquote>
<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记为 <strong> T(n) = O(f(n)) </strong>，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。这里需要重点理解这个增长率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">举个例子，看下面3个代码：</span><br><span class="line"></span><br><span class="line">1、&#123;++x;&#125;</span><br><span class="line"></span><br><span class="line">2、for(i = 1; i &lt;= n; i++) &#123; ++x; &#125;</span><br><span class="line"></span><br><span class="line">3、for(j = 1; j &lt;= n; j++) </span><br><span class="line">        for(j = 1; j &lt;= n; j++) </span><br><span class="line">             &#123; ++x; &#125;</span><br><span class="line"></span><br><span class="line">上述含有 ++x 操作的语句的频度分别为1 、n 、n^2，</span><br><span class="line"></span><br><span class="line">假设问题的规模扩大了n倍，3个代码的增长率分别是1 、n 、n^2</span><br><span class="line"></span><br><span class="line">它们的时间复杂度分别为O(1)、O(n )、O(n^2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>空间复杂度</p>
</blockquote>
<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p>
<h2 id="二、查找算法">二、查找算法</h2><p>查找和排序是最基础也是最重要的两类算法，熟练地掌握这两类算法，并能对这些算法的性能进行分析很重要，这两类算法中主要包括二分查找、快速排序、归并排序等等。</p>
<blockquote>
<p>顺序查找</p>
</blockquote>
<p>顺序查找又称线性查找。它的过程为：从查找表的最后一个元素开始逐个与给定关键字比较，若某个记录的关键字和给定值比较相等，则查找成功，否则，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录查找不成功，它的缺点是效率低下。</p>
<blockquote>
<p>二分查找</p>
</blockquote>
<ul>
<li>简介<br>二分查找又称折半查找，对于有序表来说，它的优点是比较次数少，查找速度快，平均性能好。</li>
</ul>
<p>二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x，算法中止；如果x<a[n 2]，则只要在数组a的左半部分继续搜索x，如果x="">a[n/2]，则只要在数组a的右半部搜索x。</a[n></p>
<p>二分查找的时间复杂度为O(logn)</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//给定有序查找表array 二分查找给定的值data</span><br><span class="line">//查找成功返回下标 查找失败返回-1</span><br><span class="line"></span><br><span class="line">static int funBinSearch(int[] array, int data) &#123;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = array.length - 1;</span><br><span class="line"></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line"></span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line"></span><br><span class="line">        if (data == array[mid]) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if (data &lt; array[mid]) &#123;</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、排序算法">三、排序算法</h2><p>排序是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。下面主要对一些常见的排序算法做介绍，并分析它们的时空复杂度。<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307552749315.jpg" alt=""></p>
<p>常见排序算法<br>常见排序算法性能比较：<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307552811929.jpg" alt=""></p>
<p>上面这张表中有稳定性这一项，排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前和排序后他们的相对位置不发生变化。</p>
<p>下面从冒泡排序开始逐一介绍。</p>
<blockquote>
<p>冒泡排序</p>
</blockquote>
<ul>
<li>简介<br>冒泡排序的基本思想是：设排序序列的记录个数为n，进行n-1次遍历，每次遍历从开始位置依次往后比较前后相邻元素，这样较大的元素往后移，n-1次遍历结束后，序列有序。</li>
</ul>
<p>例如，对序列(3,2,1,5)进行排序的过程是：共进行3次遍历，第1次遍历时先比较3和2，交换，继续比较3和1,交换，再比较3和5，不交换，这样第1次遍历结束，最大值5在最后的位置，得到序列(2,1,3,5)。第2次遍历时先比较2和1，交换，继续比较2和3，不交换，第2次遍历结束时次大值3在倒数第2的位置，得到序列(1,2,3,5)，第3次遍历时，先比较1和2，不交换，得到最终有序序列(1,2,3,5)。</p>
<p>需要注意的是，如果在某次遍历中没有发生交换，那么就不必进行下次遍历，因为序列已经有序。</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序 注意 flag 的作用</span><br><span class="line">static void funBubbleSort(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">    boolean flag = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length - 1 &amp;&amp; flag; i++) &#123;</span><br><span class="line"></span><br><span class="line">        flag = false;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;</span><br><span class="line"></span><br><span class="line">            if (array[j] &gt; array[j + 1]) &#123;</span><br><span class="line"></span><br><span class="line">                int temp = array[j];</span><br><span class="line">                array[j] = array[j + 1];</span><br><span class="line">                array[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析<br>最佳情况下冒泡排序只需一次遍历就能确定数组已经排好序，不需要进行下一次遍历，所以最佳情况下，时间复杂度为<strong> O(n) </strong>。</li>
</ul>
<p>最坏情况下冒泡排序需要n-1次遍历，第一次遍历需要比较n-1次，第二次遍历需要n-2次，…，最后一次需要比较1次，最差情况下时间复杂度为<strong> O(n^2) </strong>。</p>
<blockquote>
<p>简单选择排序</p>
</blockquote>
<ul>
<li>简介<br>简单选择排序的思想是：设排序序列的记录个数为n，进行n-1次选择，每次在n-i+1(i = 1,2,…,n-1)个记录中选择关键字最小的记录作为有效序列中的第i个记录。</li>
</ul>
<p>例如，排序序列(3,2,1,5)的过程是，进行3次选择，第1次选择在4个记录中选择最小的值为1，放在第1个位置，得到序列(1,3,2,5)，第2次选择从位置1开始的3个元素中选择最小的值2放在第2个位置，得到有序序列(1,2,3,5)，第3次选择因为最小的值3已经在第3个位置不需要操作，最后得到有序序列（1,2,3,5）。</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void funSelectionSort(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line"></span><br><span class="line">        int mink = i;</span><br><span class="line"></span><br><span class="line">            // 每次从未排序数组中找到最小值的坐标</span><br><span class="line">        for (int j = i + 1; j &lt; array.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">            if (array[j] &lt; array[mink]) &#123;</span><br><span class="line">                mink = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将最小值放在最前面</span><br><span class="line">        if (mink != i) &#123;</span><br><span class="line">            int temp = array[mink];</span><br><span class="line">            array[mink] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p>简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况<strong> 无关。当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为 O(n^2) ，进行移动操作的时间复杂度为 O(n) 。总的时间复杂度为 O(n^2) </strong>。</p>
<p>最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，即待排序记录初始状态是按第一条记录最大，之后的记录从小到大顺序排列，则需要移动记录的次数最多为3（n-1）。</p>
<p>简单选择排序是不稳定排序。</p>
<blockquote>
<p>直接插入排序</p>
</blockquote>
<ul>
<li>简介<br>直接插入的思想是：是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。</li>
</ul>
<p>例如，排序序列(3,2,1,5)的过程是，初始时有序序列为(3)，然后从位置1开始，先访问到2，将2插入到3前面，得到有序序列(2,3)，之后访问1,找到合适的插入位置后得到有序序列(1,2,3)，最后访问5，得到最终有序序列(1,2,3,5).</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void funDInsertSort(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">    int j;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        int temp = array[i];</span><br><span class="line"></span><br><span class="line">        j = i - 1;</span><br><span class="line"></span><br><span class="line">        while (j &gt; -1 &amp;&amp; temp &lt; array[j]) &#123;</span><br><span class="line"></span><br><span class="line">            array[j + 1] = array[j];</span><br><span class="line"></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p>最好情况下，当待排序序列中记录已经有序时，则需要n-1次比较，不需要移动，时间复杂度为<strong> O(n) 。最差情况下，当待排序序列中所有记录正好逆序时，则比较次数和移动次数都达到最大值，时间复杂度为 O(n^2) 。平均情况下，时间复杂度为 O(n^2) </strong>。</p>
<blockquote>
<p>希尔排序</p>
</blockquote>
<p>希尔排序又称“缩小增量排序”，它是基于直接插入排序的以下两点性质而提出的一种改进：(1) 直接插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。(2) 直接插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。点击查看更多关于希尔排序的内容</p>
<blockquote>
<p>归并排序</p>
</blockquote>
<ul>
<li>简介</li>
</ul>
<p>归并排序是分治法的一个典型应用，它的主要思想是：将待排序序列分为两部分，对每部分递归地应用归并排序，在两部分都排好序后进行合并。</p>
<p>例如，排序序列(3,2,8,6,7,9,1,5)的过程是，先将序列分为两部分，(3,2,8,6)和(7,9,1,5)，然后对两部分分别应用归并排序，第1部分(3,2,8,6)，第2部分(7,9,1,5)，对两个部分分别进行归并排序，第1部分继续分为(3,2)和(8,6)，(3,2)继续分为(3)和(2)，(8,6)继续分为(8)和(6)，之后进行合并得到(2,3)，(6,8)，再合并得到(2,3,6,8)，第2部分进行归并排序得到(1,5,7,9)，最后合并两部分得到(1,2,3,5,6,7,8,9)。</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//归并排序</span><br><span class="line">static void funMergeSort(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">    if (array.length &gt; 1) &#123;</span><br><span class="line"></span><br><span class="line">        int length1 = array.length / 2;</span><br><span class="line">        int[] array1 = new int[length1];</span><br><span class="line">        System.arraycopy(array, 0, array1, 0, length1);</span><br><span class="line">        funMergeSort(array1);</span><br><span class="line"></span><br><span class="line">        int length2 = array.length - length1;</span><br><span class="line">        int[] array2 = new int[length2];</span><br><span class="line">        System.arraycopy(array, length1, array2, 0, length2);</span><br><span class="line">        funMergeSort(array2);</span><br><span class="line"></span><br><span class="line">        int[] datas = merge(array1, array2);</span><br><span class="line">        System.arraycopy(datas, 0, array, 0, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//合并两个数组</span><br><span class="line">static int[] merge(int[] list1, int[] list2) &#123;</span><br><span class="line"></span><br><span class="line">    int[] list3 = new int[list1.length + list2.length];</span><br><span class="line"></span><br><span class="line">    int count1 = 0;</span><br><span class="line">    int count2 = 0;</span><br><span class="line">    int count3 = 0;</span><br><span class="line"></span><br><span class="line">    while (count1 &lt; list1.length &amp;&amp; count2 &lt; list2.length) &#123;</span><br><span class="line"></span><br><span class="line">        if (list1[count1] &lt; list2[count2]) &#123;</span><br><span class="line">            list3[count3++] = list1[count1++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list3[count3++] = list2[count2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (count1 &lt; list1.length) &#123;</span><br><span class="line">        list3[count3++] = list1[count1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (count2 &lt; list2.length) &#123;</span><br><span class="line">        list3[count3++] = list2[count2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p>归并排序的时间复杂度为O(nlogn)，它是一种稳定的排序，java.util.Arrays类中的sort方法就是使用归并排序的变体来实现的。</p>
<blockquote>
<p>快速排序</p>
</blockquote>
<ul>
<li><p>简介<br>快速排序的主要思想是：在待排序的序列中选择一个称为主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分中的所有元素都大于主元，然后对两部分递归地应用快速排序算法。</p>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">static void funQuickSort(int[] mdata, int start, int end) &#123;</span><br><span class="line">    if (end &gt; start) &#123;</span><br><span class="line">        int pivotIndex = quickSortPartition(mdata, start, end);</span><br><span class="line">        funQuickSort(mdata, start, pivotIndex - 1);</span><br><span class="line">        funQuickSort(mdata, pivotIndex + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 快速排序前的划分</span><br><span class="line">static int quickSortPartition(int[] list, int first, int last) &#123;</span><br><span class="line"></span><br><span class="line">    int pivot = list[first];</span><br><span class="line">    int low = first + 1;</span><br><span class="line">    int high = last;</span><br><span class="line"></span><br><span class="line">    while (high &gt; low) &#123;</span><br><span class="line"></span><br><span class="line">        while (low &lt;= high &amp;&amp; list[low] &lt;= pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (low &lt;= high &amp;&amp; list[high] &gt; pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (high &gt; low) &#123;</span><br><span class="line">            int temp = list[high];</span><br><span class="line">            list[high] = list[low];</span><br><span class="line">            list[low] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (high &gt; first &amp;&amp; list[high] &gt;= pivot) &#123;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pivot &gt; list[high]) &#123;</span><br><span class="line">        list[first] = list[high];</span><br><span class="line">        list[high] = pivot;</span><br><span class="line">        return high;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p>在快速排序算法中，比较关键的一个部分是主元的选择。在最差情况下，划分由n个元素构成的数组需要进行n次比较和n次移动，因此划分需要的时间是O(n)。在最差情况下，每次主元会将数组划分为一个大的子数组和一个空数组，这个大的子数组的规模是在上次划分的子数组的规模上减1，这样在最差情况下算法需要(n-1)+(n-2)+…+1= <strong> O(n^2) </strong>时间。</p>
<p>最佳情况下，每次主元将数组划分为规模大致相等的两部分，时间复杂度为<strong> O(nlogn) </strong>。</p>
<blockquote>
<p>堆排序</p>
</blockquote>
<ul>
<li>简介</li>
</ul>
<p>在介绍堆排序之前首先需要了解堆的定义，n个关键字序列K1，K2，…，Kn称为堆，当且仅当该序列满足如下性质（简称为堆性质）：(1) ki &lt;= k(2i）且 ki &lt;= k(2i+1) (1 ≤ i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。</p>
<p>如果将上面满足堆性质的序列看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有的非终端节点的值均不大于（或不小于）其左右孩子节点的值。</p>
<p>堆排序的主要思想是：给定一个待排序序列，首先经过一次调整，将序列构建成一个大顶堆，此时第一个元素是最大的元素，将其和序列的最后一个元素交换，然后对前n-1个元素调整为大顶堆，再将其第一个元素和末尾元素交换，这样最后即可得到有序序列。</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//堆排序</span><br><span class="line">public class TestHeapSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123; 5, 6, 1, 0, 2, 9 &#125;;</span><br><span class="line">        heapsort(arr, 6);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void heapsort(int arr[], int n) &#123;</span><br><span class="line"></span><br><span class="line">        // 先建大顶堆</span><br><span class="line">        for (int i = n / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            swap(arr, 0, n - i - 1);</span><br><span class="line">            heapAdjust(arr, 0, n - i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换两个数</span><br><span class="line">    static void swap(int arr[], int low, int high) &#123;</span><br><span class="line">        int temp = arr[low];</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调整堆</span><br><span class="line">    static void heapAdjust(int arr[], int index, int n) &#123;</span><br><span class="line"></span><br><span class="line">        int temp = arr[index];</span><br><span class="line"></span><br><span class="line">        int child = 0;</span><br><span class="line"></span><br><span class="line">        while (index * 2 + 1 &lt; n) &#123;</span><br><span class="line">                        </span><br><span class="line">            child = index * 2 + 1;</span><br><span class="line">                        </span><br><span class="line">            // child为左右孩子中较大的那个</span><br><span class="line">            if (child != n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指定节点大于较大的孩子 不需要调整</span><br><span class="line">            if (temp &gt; arr[child]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 否则继续往下判断孩子的孩子 直到找到合适的位置</span><br><span class="line">                arr[index] = arr[child];</span><br><span class="line">                index = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<p>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序时间复杂度也为O(nlogn)，空间复杂度为O(1)。它是不稳定的排序方法。与快排和归并排序相比，堆排序在最差情况下的时间复杂度优于快排，空间效率高于归并排序。</p>
<h2 id="四、其它算法">四、其它算法</h2><p>在上面的篇幅中，主要是对查找和常见的几种排序算法作了介绍，这些内容都是基础的但是必须掌握的内容，尤其是二分查找、快排、堆排、归并排序这几个更是面试高频考察点。（这里不禁想起百度一面的时候让我写二分查找和堆排序，二分查找还行，然而堆排序当时一脸懵逼…）下面主要是介绍一些常见的其它算法。</p>
<blockquote>
<p>递归</p>
</blockquote>
<ul>
<li>简介</li>
</ul>
<p>在平常解决一些编程或者做一些算法题的时候，经常会用到递归。程序调用自身的编程技巧称为递归。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。上面介绍的快速排序和归并排序都用到了递归的思想。</p>
<ul>
<li>经典例子</li>
</ul>
<p>斐波那契数列，又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2，n∈N*）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//斐波那契数列 递归实现</span><br><span class="line">static long funFib(long index) &#123;</span><br><span class="line"></span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if (index == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return funFib(index - 1) + funFib(index - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是斐波那契数列的递归实现，然而我们不难得到它的时间复杂度是O(2^n)，递归有时候可以很方便地解决一些问题，但是它也会带来一些效率上的问题。下面的代码是求斐波那契数列的另一种方式，效率比递归方法的效率高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static long funFib2(long index) &#123;</span><br><span class="line"></span><br><span class="line">    long f0 = 0;</span><br><span class="line">    long f1 = 1;</span><br><span class="line">    long f2 = 1;</span><br><span class="line"></span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">        return f0;</span><br><span class="line">    &#125; else if (index == 1) &#123;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125; else if (index == 2) &#123;</span><br><span class="line">        return f2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 3; i &lt;= index; i++) &#123;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f0 + f1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分治算法</p>
</blockquote>
<p>分治算法的思想是将待解决的问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后合并这些子问题的解来建立最终的解。分治算法中关键地一步其实就是递归地求解子问题。关于分治算法的一个典型例子就是上面介绍的归并排序。查看更多关于分治算法的内容</p>
<blockquote>
<p>动态规划</p>
</blockquote>
<p>动态规划与分治方法相似，都是通过组合子问题的解来求解待解决的问题。但是，分治算法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，而动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。动态规划方法通常用来求解最优化问题。查看更多关于动态规划的内容</p>
<p>动态规划典型的一个例子是最长公共子序列问题。</p>
<p>常见的算法还有很多，比如贪心算法，回溯算法等等，这里都不再详细介绍，想要熟练掌握，还是要靠刷题，刷题，刷题，然后总结。</p>
<h2 id="五、常见算法题">五、常见算法题</h2><p>下面是一些常见的算法题汇总。</p>
<blockquote>
<p>不使用临时变量交换两个数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void funSwapTwo(int a, int b) &#123;</span><br><span class="line"></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = b ^ a;</span><br><span class="line">    a = a ^ b;</span><br><span class="line"></span><br><span class="line">    System.out.println(a + &quot; &quot; + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断一个数是否为素数</p>
</blockquote>
<p>static boolean funIsPrime(int m) {</p>
<pre><code>boolean <span class="variable">flag =</span> <span class="constant">true</span>;

<span class="keyword">if</span> (<span class="variable">m =</span>= <span class="number">1</span>) {
    <span class="variable">flag =</span> <span class="constant">false</span>;
} <span class="keyword">else</span> {

    for (int <span class="variable">i =</span> <span class="number">2</span>; i &lt;= Math.sqrt(m); i++) {
        <span class="keyword">if</span> (m % <span class="variable">i =</span>= <span class="number">0</span>) {
            <span class="variable">flag =</span> <span class="constant">false</span>;
            break;
        }
    }
}

return flag;
</code></pre><p>}<br>其它算法题</p>
<p>1、<a href="http://www.codeceo.com/article/15-algorithms-question.html" target="_blank" rel="noopener">15道使用频率极高的基础算法题</a><br>2、<a href="https://blog.csdn.net/luckyxiaoqiang/article/details/7518888/" target="_blank" rel="noopener">二叉树相关算法题</a><br>3、<a href="https://blog.csdn.net/kerryfish/article/details/24043099" target="_blank" rel="noopener">链表相关算法题</a><br>4、<a href="http://blog.chinaunix.net/uid-20498361-id-1940276.html" target="_blank" rel="noopener">字符串相关算法问题</a></p>
<h2 id="六、总结">六、总结</h2><p>以上就是自己对常见的算法相关内容的总结，算法虐我千百遍，我待算法如初恋，革命尚未成功，同志仍需刷题，加油。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2018/07/05/2018-07-05/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/05/2018-07-05/" class="post-title-link" itemprop="url">常见数据结构与算法整理总结（上）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-05 16:09:10 / 修改时间：09:35:50" itemprop="dateCreated datePublished" datetime="2018-07-05T16:09:10+08:00">2018-07-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见数据结构与算法整理总结（上）">常见数据结构与算法整理总结（上）</h1><p>[toc]</p>
<blockquote>
<p>数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。下面是自己整理的常用数据结构与算法相关内容，如有错误，欢迎指出。</p>
</blockquote>
<p>为了便于描述，文中涉及到的代码部分都是用Java语言编写的，其实Java本身对常见的几种数据结构，线性表、栈、队列等都提供了较好的实现，就是我们经常用到的Java集合框架，有需要的可以阅读这篇文章。Java - 集合框架完全解析</p>
<h2 id="一、线性表">一、线性表</h2><p>线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。</p>
<p>实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）。</p>
<blockquote>
<p>数组实现</p>
</blockquote>
<p>数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建之后，它的大小就无法改变了，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前数组。这样就可以使用数组实现动态的数据结构。</p>
<ul>
<li>代码1 创建一个更大的数组来替换当前数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int[] oldArray = new int[10];</span><br><span class="line">        </span><br><span class="line">int[] newArray = new int[20];</span><br><span class="line">        </span><br><span class="line">for (int i = 0; i &lt; oldArray.length; i++) &#123;</span><br><span class="line">    newArray[i] = oldArray[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以使用System.arraycopy方法来实现数组间的复制     </span><br><span class="line">// System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);</span><br><span class="line">        </span><br><span class="line">oldArray = newArray;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码2 在数组位置index上添加元素e</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//oldArray 表示当前存储元素的数组</span><br><span class="line">//size 表示当前元素个数</span><br><span class="line">public void add(int index, int e) &#123;</span><br><span class="line"></span><br><span class="line">    if (index &gt; size || index &lt; 0) &#123;</span><br><span class="line">        System.out.println(&quot;位置不合法...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果数组已经满了 就扩容</span><br><span class="line">    if (size &gt;= oldArray.length) &#123;</span><br><span class="line">        // 扩容函数可参考代码1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = size - 1; i &gt;= index; i--) &#123;</span><br><span class="line">        oldArray[i + 1] = oldArray[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将数组elementData从位置index的所有元素往后移一位</span><br><span class="line">    // System.arraycopy(oldArray, index, oldArray, index + 1,size - index);</span><br><span class="line"></span><br><span class="line">    oldArray[index] = e;</span><br><span class="line"></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面简单写出了数组实现线性表的两个典型函数，具体我们可以参考Java里面的ArrayList集合类的源码。数组实现的线性表优点在于可以通过下标来访问或者修改元素，比较高效，主要缺点在于插入和删除的花费开销较大，比如当在第一个位置前插入一个元素，那么首先要把所有的元素往后移动一个位置。为了提高在任意位置添加或者删除元素的效率，可以采用链式结构来实现线性表。</p>
<blockquote>
<p>链表</p>
</blockquote>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，这些节点不必在内存中相连。每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307206577653.jpg" alt=""></p>
<p>下面主要用代码来展示链表的一些基本操作，需要注意的是，这里主要是以单链表为例，暂时不考虑双链表和循环链表。</p>
<ul>
<li>代码3 链表的节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Node&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">    //构造函数</span><br><span class="line">    Node(E element) &#123;</span><br><span class="line">       this.item = element;</span><br><span class="line">       this.next = null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码4 定义好节点后，使用前一般是对头节点和尾节点进行初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//头节点和尾节点都为空 链表为空</span><br><span class="line">Node&lt;E&gt; head = null;</span><br><span class="line">Node&lt;E&gt; tail = null;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码5 空链表创建一个新节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个新的节点 并让head指向此节点</span><br><span class="line">head = new Node(&quot;nodedata1&quot;);</span><br><span class="line"></span><br><span class="line">//让尾节点也指向此节点</span><br><span class="line">tail = head;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码6 链表追加一个节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建新节点 同时和最后一个节点连接起来</span><br><span class="line">tail.next = new Node(&quot;node1data2&quot;);</span><br><span class="line"></span><br><span class="line">//尾节点指向新的节点</span><br><span class="line">tail = tail.next;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码7 顺序遍历链表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;String&gt; current = head;</span><br><span class="line">while (current != null) &#123;</span><br><span class="line">    System.out.println(current.item);</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码8 倒序遍历链表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void printListRev(Node&lt;String&gt; head) &#123;</span><br><span class="line">//倒序遍历链表主要用了递归的思想</span><br><span class="line">    if (head != null) &#123;</span><br><span class="line">        printListRev(head.next);</span><br><span class="line">        System.out.println(head.item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码 单链表反转</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//单链表反转 主要是逐一改变两个节点间的链接关系来完成</span><br><span class="line">static Node&lt;String&gt; revList(Node&lt;String&gt; head) &#123;</span><br><span class="line"></span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;String&gt; nodeResult = null;</span><br><span class="line"></span><br><span class="line">    Node&lt;String&gt; nodePre = null;</span><br><span class="line">    Node&lt;String&gt; current = head;</span><br><span class="line"></span><br><span class="line">    while (current != null) &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;String&gt; nodeNext = current.next;</span><br><span class="line"></span><br><span class="line">        if (nodeNext == null) &#123;</span><br><span class="line">            nodeResult = current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current.next = nodePre;</span><br><span class="line">        nodePre = current;</span><br><span class="line">        current = nodeNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nodeResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的几段代码主要展示了链表的几个基本操作，还有很多像获取指定元素，移除元素等操作大家可以自己完成，写这些代码的时候一定要理清节点之间关系，这样才不容易出错。</p>
<p>链表的实现还有其它的方式，常见的有循环单链表，双向链表，循环双向链表。 循环单链表 主要是链表的最后一个节点指向第一个节点，整体构成一个链环。 双向链表 主要是节点中包含两个指针部分，一个指向前驱元，一个指向后继元，JDK中LinkedList集合类的实现就是双向链表。<strong> 循环双向链表</strong> 是最后一个节点指向第一个节点。</p>
<h2 id="二、栈与队列">二、栈与队列</h2><p>栈和队列也是比较常见的数据结构，它们是比较特殊的线性表，因为对于栈来说，访问、插入和删除元素只能在栈顶进行，对于队列来说，元素只能从队列尾插入，从队列头访问和删除。</p>
<blockquote>
<p>栈</p>
</blockquote>
<p>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈顶，对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者相当于删除最后一个元素。栈有时又叫作LIFO(Last In First Out)表，即后进先出。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307210138875.jpg" alt="栈的模型
"></p>
<p>下面我们看一道经典题目，加深对栈的理解。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307210317919.jpg" alt="关于栈的一道经典题目
"></p>
<p>上图中的答案是C，其中的原理可以好好想一想。</p>
<p>因为栈也是一个表，所以任何实现表的方法都能实现栈。我们打开JDK中的类Stack的源码，可以看到它就是继承类Vector的。当然，Stack是Java2前的容器类，现在我们可以使用LinkedList来进行栈的所有操作。</p>
<blockquote>
<p>队列</p>
</blockquote>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307210815831.jpg" alt="队列示意图
"></p>
<p>我们可以使用链表来实现队列，下面代码简单展示了利用LinkedList来实现队列类。</p>
<ul>
<li>代码9 简单实现队列类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyQueue&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private LinkedList&lt;E&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 入队</span><br><span class="line">    public void enqueue(E e) &#123;</span><br><span class="line">        list.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 出队</span><br><span class="line">    public E dequeue() &#123;</span><br><span class="line">        return list.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通的队列是一种先进先出的数据结构，而优先队列中，元素都被赋予优先级。当访问元素的时候，具有最高优先级的元素最先被删除。优先队列在生活中的应用还是比较多的，比如医院的急症室为病人赋予优先级，具有最高优先级的病人最先得到治疗。在Java集合框架中，类PriorityQueue就是优先队列的实现类，具体大家可以去阅读源码。</p>
<h2 id="三、树与二叉树">三、树与二叉树</h2><p>树型结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用。在介绍二叉树之前，我们先简单了解一下树的相关内容。</p>
<blockquote>
<p>树</p>
</blockquote>
<p><strong> 树 是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。它具有以下特点：每个节点有零个或多个子节点；没有父节点的节点称为 根 节点；每一个非根节点有且只有一个 父节点 </strong>；除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307211821748.jpg" alt="树的结构
"></p>
<blockquote>
<p>二叉树基本概念</p>
</blockquote>
<ul>
<li><strong>定义</strong></li>
</ul>
<p>二叉树是每个节点最多有两棵子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树常被用于实现二叉查找树和二叉堆。</p>
<ul>
<li><strong>相关性质</strong></li>
</ul>
<p>二叉树的每个结点至多只有2棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。</p>
<p>二叉树的第i层至多有2(i-1)个结点；深度为k的二叉树至多有2k-1个结点。</p>
<p>一棵深度为k，且有2^k-1个节点的二叉树称之为<strong> 满二叉树 </strong>；</p>
<p>深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为<strong> 完全二叉树 </strong>。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307212581214.jpg" alt=""></p>
<ul>
<li>三种遍历方法</li>
</ul>
<p>在二叉树的一些应用中，常常要求在树中查找具有某种特征的节点，或者对树中全部节点进行某种处理，这就涉及到二叉树的遍历。二叉树主要是由3个基本单元组成，根节点、左子树和右子树。如果限定先左后右，那么根据这三个部分遍历的顺序不同，可以分为先序遍历、中序遍历和后续遍历三种。</p>
<p>(1) 先序遍历 若二叉树为空，则空操作，否则先访问根节点，再先序遍历左子树，最后先序遍历右子树。 (2) 中序遍历 若二叉树为空，则空操作，否则先中序遍历左子树，再访问根节点，最后中序遍历右子树。(3) 后序遍历 若二叉树为空，则空操作，否则先后序遍历左子树访问根节点，再后序遍历右子树，最后访问根节点。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307212790800.jpg" alt=""></p>
<p>给定二叉树写出三种遍历结果</p>
<ul>
<li>树和二叉树的区别</li>
</ul>
<p>(1) 二叉树每个节点最多有2个子节点，树则无限制。 (2) 二叉树中节点的子树分为左子树和右子树，即使某节点只有一棵子树，也要指明该子树是左子树还是右子树，即二叉树是有序的。 (3) 树决不能为空，它至少有一个节点，而一棵二叉树可以是空的。</p>
<p>上面我们主要对二叉树的相关概念进行了介绍，下面我们将从二叉查找树开始，介绍二叉树的几种常见类型，同时将之前的理论部分用代码实现出来。</p>
<blockquote>
<p>二叉查找树</p>
</blockquote>
<ul>
<li>定义</li>
</ul>
<p>二叉查找树就是二叉排序树，也叫二叉搜索树。二叉查找树或者是一棵空树，或者是具有下列性质的二叉树： (1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；(2) 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；(3) 左、右子树也分别为二叉排序树；(4) 没有键值相等的结点。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307213483050.jpg" alt="典型的二叉查找树的构建过程
"></p>
<ul>
<li>性能分析</li>
</ul>
<p>对于二叉查找树来说，当给定值相同但顺序不同时，所构建的二叉查找树形态是不同的，下面看一个例子。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307214196777.jpg" alt="不同形态平衡二叉树的ASL不同
"></p>
<p>可以看到，含有n个节点的二叉查找树的平均查找长度和树的形态有关。最坏情况下，当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树，树的深度为n，其平均查找长度(n+1)/2(和顺序查找相同），最好的情况是二叉查找树的形态和折半查找的判定树相同，其平均查找长度和log2(n)成正比。平均情况下，二叉查找树的平均查找长度和logn是等数量级的，所以为了获得更好的性能，通常在二叉查找树的构建过程需要进行“平衡化处理”，之后我们将介绍平衡二叉树和红黑树，这些均可以使查找树的高度为O(log(n))。</p>
<ul>
<li>代码10 二叉树的节点</li>
</ul>
<p>class TreeNode<e> {</e></p>
<pre><code><span class="keyword">E</span> element;
TreeNode&lt;<span class="keyword">E</span>&gt; left;
TreeNode&lt;<span class="keyword">E</span>&gt; right;

public TreeNode(<span class="keyword">E</span> <span class="keyword">e</span>) {
    element = <span class="keyword">e</span>;
}
</code></pre><p>}<br>二叉查找树的三种遍历都可以直接用递归的方法来实现：</p>
<ul>
<li>代码12 先序遍历</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void preorder(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line"></span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    System.out.println(root.element + &quot; &quot;);</span><br><span class="line"></span><br><span class="line">    preorder(root.left);</span><br><span class="line"></span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码13 中序遍历</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void inorder(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line"></span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    inorder(root.left);</span><br><span class="line"></span><br><span class="line">    System.out.println(root.element + &quot; &quot;);</span><br><span class="line"></span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码14 后序遍历</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void postorder(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line"></span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    postorder(root.left);</span><br><span class="line"></span><br><span class="line">    postorder(root.right);</span><br><span class="line"></span><br><span class="line">    System.out.println(root.element + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码15 二叉查找树的简单实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author JackalTsc</span><br><span class="line"> */</span><br><span class="line">public class MyBinSearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 根</span><br><span class="line">    private TreeNode&lt;E&gt; root;</span><br><span class="line"></span><br><span class="line">    // 默认构造函数</span><br><span class="line">    public MyBinSearchTree() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二叉查找树的搜索</span><br><span class="line">    public boolean search(E e) &#123;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;E&gt; current = root;</span><br><span class="line"></span><br><span class="line">        while (current != null) &#123;</span><br><span class="line"></span><br><span class="line">            if (e.compareTo(current.element) &lt; 0) &#123;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; else if (e.compareTo(current.element) &gt; 0) &#123;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二叉查找树的插入</span><br><span class="line">    public boolean insert(E e) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果之前是空二叉树 插入的元素就作为根节点</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            root = createNewNode(e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则就从根节点开始遍历 直到找到合适的父节点</span><br><span class="line">            TreeNode&lt;E&gt; parent = null;</span><br><span class="line">            TreeNode&lt;E&gt; current = root;</span><br><span class="line">            while (current != null) &#123;</span><br><span class="line">                if (e.compareTo(current.element) &lt; 0) &#123;</span><br><span class="line">                    parent = current;</span><br><span class="line">                    current = current.left;</span><br><span class="line">                &#125; else if (e.compareTo(current.element) &gt; 0) &#123;</span><br><span class="line">                    parent = current;</span><br><span class="line">                    current = current.right;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 插入</span><br><span class="line">            if (e.compareTo(parent.element) &lt; 0) &#123;</span><br><span class="line">                parent.left = createNewNode(e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parent.right = createNewNode(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建新的节点</span><br><span class="line">    protected TreeNode&lt;E&gt; createNewNode(E e) &#123;</span><br><span class="line">        return new TreeNode(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二叉树的节点</span><br><span class="line">class TreeNode&lt;E extends Comparable&lt;E&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    E element;</span><br><span class="line">    TreeNode&lt;E&gt; left;</span><br><span class="line">    TreeNode&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">    public TreeNode(E e) &#123;</span><br><span class="line">        element = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码15主要展示了一个自己实现的简单的二叉查找树，其中包括了几个常见的操作，当然更多的操作还是需要大家自己去完成。因为在二叉查找树中删除节点的操作比较复杂，所以下面我详细介绍一下这里。</p>
<p>二叉查找树中删除节点分析<br>要在二叉查找树中删除一个元素，首先需要定位包含该元素的节点，以及它的父节点。假设current指向二叉查找树中包含该元素的节点，而parent指向current节点的父节点，current节点可能是parent节点的左孩子，也可能是右孩子。这里需要考虑两种情况：</p>
<p>1、current节点没有左孩子，那么只需要将patent节点和current节点的右孩子相连。<br>2、current节点有一个左孩子，假设rightMost指向包含current节点的左子树中最大元素的节点，而parentOfRightMost指向rightMost节点的父节点。那么先使用rightMost节点中的元素值替换current节点中的元素值，将parentOfRightMost节点和rightMost节点的左孩子相连，然后删除rightMost节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 二叉搜索树删除节点</span><br><span class="line">public boolean delete(E e) &#123;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;E&gt; parent = null;</span><br><span class="line">    TreeNode&lt;E&gt; current = root;</span><br><span class="line"></span><br><span class="line">    // 找到要删除的节点的位置</span><br><span class="line">    while (current != null) &#123;</span><br><span class="line">        if (e.compareTo(current.element) &lt; 0) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; else if (e.compareTo(current.element) &gt; 0) &#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 没找到要删除的节点</span><br><span class="line">    if (current == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 考虑第一种情况</span><br><span class="line">    if (current.left == null) &#123;</span><br><span class="line">        if (parent == null) &#123;</span><br><span class="line">            root = current.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (e.compareTo(parent.element) &lt; 0) &#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parent.right = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 考虑第二种情况</span><br><span class="line">        TreeNode&lt;E&gt; parentOfRightMost = current;</span><br><span class="line">        TreeNode&lt;E&gt; rightMost = current.left;</span><br><span class="line">        // 找到左子树中最大的元素节点</span><br><span class="line">        while (rightMost.right != null) &#123;</span><br><span class="line">            parentOfRightMost = rightMost;</span><br><span class="line">            rightMost = rightMost.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 替换</span><br><span class="line">        current.element = rightMost.element;</span><br><span class="line"></span><br><span class="line">        // parentOfRightMost和rightMost左孩子相连</span><br><span class="line">        if (parentOfRightMost.right == rightMost) &#123;</span><br><span class="line">            parentOfRightMost.right = rightMost.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parentOfRightMost.left = rightMost.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>平衡二叉树</p>
</blockquote>
<p>平衡二叉树又称AVL树，它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15307217090333.jpg" alt="平衡二叉树
"></p>
<p>AVL树是最先发明的自平衡二叉查找树算法。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<blockquote>
<p>红黑树</p>
</blockquote>
<p>红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的事件复杂度为O(log n)。红黑树和平衡二叉树区别如下：(1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。(2) 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。点击查看更多</p>
<h2 id="四、图">四、图</h2><ul>
<li>简介</li>
</ul>
<p>图是一种较线性表和树更为复杂的数据结构，在线性表中，数据元素之间仅有线性关系，在树形结构中，数据元素之间有着明显的层次关系，而在图形结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。图的应用相当广泛，特别是近年来的迅速发展，已经渗入到诸如语言学、逻辑学、物理、化学、电讯工程、计算机科学以及数学的其他分支中。</p>
<ul>
<li>相关阅读</li>
</ul>
<p>因为图这部分的内容还是比较多的，这里就不详细介绍了，有需要的可以自己搜索相关资料。</p>
<p>(1) 《百度百科对图的介绍》<br>(2) 《数据结构之图（存储结构、遍历）》</p>
<h2 id="五、总结">五、总结</h2><p>到这里，关于常见的数据结构的整理就结束了，断断续续大概花了两天时间写完，在总结的过程中，通过查阅相关资料，结合书本内容，收获还是很大的，在下一篇博客中将会介绍常用数据结构与算法整理总结（下）之算法篇，欢迎大家关注。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2018/07/04/2018-07-04/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/04/2018-07-04/" class="post-title-link" itemprop="url">Java - 集合框架完全解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-04 16:09:10 / 修改时间：14:13:43" itemprop="dateCreated datePublished" datetime="2018-07-04T16:09:10+08:00">2018-07-04</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java_-_集合框架完全解析">Java - 集合框架完全解析</h1><p>[toc]</p>
<p>数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效地组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。在平常的学习开发中，灵活熟练地使用这些集合框架，可以很明显地提高我们的开发效率，当然仅仅会用还是不够的，理解其中的设计思想与原理才能更好地提高我们的开发水平。下面是自己对Java集合框架方面的学习总结。</p>
<h2 id="一、概述">一、概述</h2><p>在Java 2之前，Java是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如Vector，Stack，Hashtable等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在Java 2中，Java设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15306758562015.jpg" alt=""></p>
<p>从上面的集合框架图可以看到，Java集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。</p>
<h2 id="二、Collection接口">二、Collection接口</h2><p>Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法，AbstractCollection是提供Collection部分实现的抽象类。下图展示了Collection接口中的全部方法。<br><img src="http://7xigvj.com1.z0.glb.clouddn.com/15306759708711.jpg" alt="Collection接口结构"></p>
<p>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。Collection接口有三个子接口，下面详细介绍。</p>
<h3 id="1-List">1.List</h3><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要是提供对链表的支持。下面介绍List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。</p>
<blockquote>
<p>ArrayList</p>
</blockquote>
<p>通过阅读ArrayList的源码，我们可以很清楚地看到里面的逻辑，它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1、方法add(E e)向集合中添加指定元素。</span><br><span class="line"></span><br><span class="line">   public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">2、此方法主要是确定将要创建的数组大小。</span><br><span class="line"></span><br><span class="line">  private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。</span><br><span class="line"></span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LinkedList</p>
</blockquote>
<p>同样，我们打开LinkedList的源文件，不难看到LinkedList是在一个链表中存储元素。</p>
<p>在学习数据结构的时候，我们知道链表和数组的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同，同样，ArrayList与LinkedList也是如此，实际使用中我们需要根据特定的需求选用合适的类，如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList。</p>
<h3 id="2-Set">2.Set</h3><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。在一个规则集内，一定不存在两个相等的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p>
<blockquote>
<p>散列集HashSet</p>
</blockquote>
<p>散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。</p>
<p>下面看一个HashSet的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author JackalTsc</span><br><span class="line"> */</span><br><span class="line">public class TestHashSet &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        set.add(&quot;11111&quot;);</span><br><span class="line">        set.add(&quot;22222&quot;);</span><br><span class="line">        set.add(&quot;33333&quot;);</span><br><span class="line">        set.add(&quot;44444&quot;);</span><br><span class="line">        set.add(&quot;22222&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(set.size());</span><br><span class="line"></span><br><span class="line">        for (String e : set) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。</p>
<blockquote>
<p>链式散列集LinkedHashSet</p>
</blockquote>
<p>LinkedHashSet是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。</p>
<blockquote>
<p>树形集TreeSet</p>
</blockquote>
<p>TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p>
<p>下面是一个TreeSet的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author JackalTsc</span><br><span class="line"> */</span><br><span class="line">public class TestSet &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        set.add(1111);</span><br><span class="line">        set.add(2222);</span><br><span class="line">        set.add(3333);</span><br><span class="line">        set.add(4444);</span><br><span class="line">        set.add(5555);</span><br><span class="line"></span><br><span class="line">        System.out.println(set.first()); // 输出第一个元素</span><br><span class="line">        System.out.println(set.lower(3333)); //小于3333的最大元素</span><br><span class="line">        System.out.println(set.higher(2222)); //大于2222的最大元素</span><br><span class="line">        System.out.println(set.floor(3333)); //不大于3333的最大元素</span><br><span class="line">        System.out.println(set.ceiling(3333)); //不小于3333的最大元素</span><br><span class="line"></span><br><span class="line">        System.out.println(set.pollFirst()); //删除第一个元素</span><br><span class="line">        System.out.println(set.pollLast()); //删除最后一个元素</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Queue">3.Queue</h3><p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15306761889611.jpg" alt="Queue接口结构
"></p>
<p>上图中，方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。</p>
<p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author JackalTsc</span><br><span class="line"> */</span><br><span class="line">public class TestQueue &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(&quot;aaaa&quot;);</span><br><span class="line">        queue.offer(&quot;bbbb&quot;);</span><br><span class="line">        queue.offer(&quot;cccc&quot;);</span><br><span class="line">        queue.offer(&quot;dddd&quot;);</span><br><span class="line"></span><br><span class="line">        while (queue.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(queue.remove() + &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Map接口">三、Map接口</h2><p>Map，图，是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在图中的是键值构成的条目。下面是接口Map的类结构。</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15306762206794.jpg" alt="接口Map的结构
"></p>
<p>从上面这张图中我们可以看到接口Map提供了很多查询、更新和获取存储的键值对的方法，更新包括方法clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。Map接口常用的有三个具体实现类，分别是HashMap、LinkedHashMap、TreeMap。</p>
<h3 id="1-HashMap">1.HashMap</h3><p>HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。我们知道ArrayList主要是用数组来存储元素的，LinkedList是用链表来存储的，那么HashMap的实现原理是什么呢？先看下面这张图：</p>
<p><img src="http://7xigvj.com1.z0.glb.clouddn.com/15306762383475.jpg" alt="HashMap原理.jpg
"></p>
<p>在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>下面主要通过源码介绍一下它的实现原理。</p>
<blockquote>
<p>HashMap存储元素的数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组的元素类型是Node<k,v>，Node<k,v>继承自Map.Entry<k,v>，表示键值对映射。</k,v></k,v></k,v></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        //构造函数 ( Hash值键值下一个节点 )</span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o == this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来我们看下HashMap的put操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">    boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;  //如果没有初始化则初始化table</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        //这里 (n-1)&amp;hash 是根据hash值得到这个元素在数组中的位置（即下标）</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    //如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //第一节节点hash值同，且key值与插入key相同</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            //属于红黑树处理冲突</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            /链表处理冲突</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                    //新增节点后如果节点个数到达阈值，则将链表转换为红黑树</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新hash值和key值均相同的节点Value值</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来我们看下HashMap的get操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">      if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">          if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">              ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">              return first;</span><br><span class="line">          if ((e = first.next) != null) &#123;</span><br><span class="line">              //如果第一个节点是TreeNode,说明采用的是数组+红黑树结构处理冲突</span><br><span class="line">  //遍历红黑树，得到节点值</span><br><span class="line">              if (first instanceof TreeNode)</span><br><span class="line">                  return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              do &#123;</span><br><span class="line">                  if (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != null &amp;&amp; </span><br><span class="line">                                                     key.equals(k))))</span><br><span class="line">                      return e;</span><br><span class="line">              &#125; while ((e = e.next) != null);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里HashMap的大致实现原理应该很清楚了，有几个需要关注的重点是：HashMap存储元素的方式以及根据Hash值确定映射在数组中的位置还有JDK 1.8之后加入的红黑树的。</p>
<blockquote>
<p>在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int h)方法所计算得到的hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中，(n - 1) &amp; hash用于计算对象应该保存在table数组的哪个索引处。HashMap底层数组的长度总是2的n次方，当数组长度为2的n次幂的时候，(n - 1) &amp; hash 算得的index相同的几率较小，数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
</blockquote>
<h3 id="2-LinkedHashMap">2.LinkedHashMap</h3><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排序。</p>
<h3 id="3-TreeMap">3.TreeMap</h3><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p>
<p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。</p>
<h2 id="四、其它集合类">四、其它集合类</h2><p>上面主要对Java集合框架作了详细的介绍，包括Collection和Map两个接口及它们的抽象类和常用的具体实现类，下面主要介绍一下其它几个特殊的集合类，Vector、Stack、HashTable、ConcurrentHashMap以及CopyOnWriteArrayList。</p>
<h3 id="1-Vector">1.Vector</h3><p>前面我们已经提到，Java设计者们在对之前的容器类进行重新设计时保留了一些数据结构，其中就有Vector。用法上，Vector与ArrayList基本一致，不同之处在于Vector使用了关键字synchronized将访问和修改向量的方法都变成同步的了，所以对于不需要同步的应用程序来说，类ArrayList比类Vector更高效。</p>
<h3 id="2-Stack">2.Stack</h3><p>Stack，栈类，是Java2之前引入的，继承自类Vector。</p>
<h3 id="3-HashTable">3.HashTable</h3><p>HashTable和前面介绍的HashMap很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，HashTable是继承自Dictionary的，HashTable中的函数都是同步的，这意味着它也是线程安全的，另外，HashTable中key和value都不可以为null。</p>
<p>上面的三个集合类都是在Java2之前推出的容器类，可以看到，尽管在使用中效率比较低，但是它们都是线程安全的。下面介绍两个特殊的集合类。</p>
<h3 id="4-ConcurrentHashMap">4.ConcurrentHashMap</h3><p>Concurrent，并发，从名字就可以看出来ConcurrentHashMap是HashMap的线程安全版。同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高。关于ConcurrentHashMap的设计，我将会在下一篇关于并发编程的博客中介绍，敬请关注。</p>
<p>5.CopyOnWriteArrayList<br>CopyOnWriteArrayList，是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。</p>
<h2 id="五、总结">五、总结</h2><p>到这里，对于Java集合框架的总结就结束了，还有很多集合类没有在这里提到，更多的还是需要大家自己去查去用。通过阅读源码，查阅资料，收获很大。</p>
<ul>
<li><p>Java集合框架主要包括Collection和Map两种类型。其中Collection又有3种子类型，分别是List、Set、Queue。Map中存储的主要是键值对映射。</p>
</li>
<li><p>规则集Set中存储的是不重复的元素，线性表中存储可以包括重复的元素，Queue队列描述的是先进先出的数据结构，可以用LinkedList来实现队列。</p>
</li>
<li><p>效率上，规则集比线性表更高效。</p>
</li>
<li><p>ArrayList主要是用数组来存储元素，LinkedList主要是用链表来存储元素，HashMap的底层实现主要是借助数组+链表+红黑树来实现。</p>
</li>
<li><p>Vector、HashTable等集合类效率比较低但都是线程安全的。包java.util.concurrent下包含了大量线程安全的集合类，效率上有较大提升。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2015/04/22/VPN-Gate镜像/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/04/22/VPN-Gate镜像/" class="post-title-link" itemprop="url">VPN Gate镜像</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-04-22 16:49:53 / 修改时间：16:55:27" itemprop="dateCreated datePublished" datetime="2015-04-22T16:49:53+08:00">2015-04-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vpngate/" itemprop="url" rel="index"><span itemprop="name">vpngate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文定期更新VPN Gate镜像站点，为自由</p>
<ol>
<li><p><a href="http://112.173.79.56:45964/" target="_blank" rel="noopener">http://112.173.79.56:45964/</a><br>(Location: Korea Republic of)</p>
</li>
<li><p><a href="http://168.115.113.159:35340/" target="_blank" rel="noopener">http://168.115.113.159:35340/</a><br>(Location: Korea Republic of)</p>
</li>
<li><p><a href="http://14.37.147.135:24165/" target="_blank" rel="noopener">http://14.37.147.135:24165/</a><br>(Location: Korea Republic of)</p>
</li>
<li><p><a href="http://180.70.94.98:62215/" target="_blank" rel="noopener">http://180.70.94.98:62215/</a><br>(Location: Korea Republic of)</p>
</li>
<li><p><a href="http://FL1-133-202-218-59.tky.mesh.ad.jp:5344/" target="_blank" rel="noopener">http://FL1-133-202-218-59.tky.mesh.ad.jp:5344/
</a><br>(Location: Japan)</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2015/04/22/Linux-Bash常用命令/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/04/22/Linux-Bash常用命令/" class="post-title-link" itemprop="url">Linux Bash常用命令</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-04-22 16:09:10 / 修改时间：16:45:22" itemprop="dateCreated datePublished" datetime="2015-04-22T16:09:10+08:00">2015-04-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>接触过Linux的童鞋肯定会知道，在Linux操作系统环境下，命令行操作有时候给我们带来极大的帮助，对于命令行“狂热者”们而言，相信Bash命令已经成为他们日常操作不可或缺的一部分。今天给大家介绍一些Bash相关的知识，让初学者认识bash，也希望能让老手更加高效利用bash命令。</p>
<h1 id="关于Bash、Shell">关于Bash、Shell</h1><p>Bash是一个为GNU计划编写的Unix shell，也是目前大多数Linux发行版采用的Shell。Shell英文翻译为“贝壳”，顾名思义，Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。 Bash是linux默认的shell，bash 的东西非常的多，包括变数的设定与使用、 bash 操作环境的建置、资料流重导向的功能，掌握一些shell操作技巧，还有那好用的管线命令是很有必要的。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2015/04/22/Linux-Bash常用命令/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2015/04/12/SSH原理与运用（一）/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/04/12/SSH原理与运用（一）/" class="post-title-link" itemprop="url">SSH原理与运用（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-04-12 21:30:32" itemprop="dateCreated datePublished" datetime="2015-04-12T21:30:32+08:00">2015-04-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2015-04-22 15:32:55" itemprop="dateModified" datetime="2015-04-22T15:32:55+08:00">2015-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ssh/" itemprop="url" rel="index"><span itemprop="name">ssh</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="什么是SSH?">什么是SSH?</h1><blockquote>
<p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。</p>
</blockquote>
<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。<br>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。<br>此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2015/04/12/SSH原理与运用（一）/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2015/04/12/SSH原理与运用（二）/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/04/12/SSH原理与运用（二）/" class="post-title-link" itemprop="url">SSH-远程操作与端口转发（二）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-04-12 21:30:32" itemprop="dateCreated datePublished" datetime="2015-04-12T21:30:32+08:00">2015-04-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2015-04-22 15:48:57" itemprop="dateModified" datetime="2015-04-22T15:48:57+08:00">2015-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ssh/" itemprop="url" rel="index"><span itemprop="name">ssh</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="远程操作">远程操作</h1><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>上一节的操作，就是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2015/04/12/SSH原理与运用（二）/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aaron-codes.github.io/2015/04/03/hello-world/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Aaron OuYang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aaron's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/04/03/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-04-03 14:04:23" itemprop="dateCreated datePublished" datetime="2015-04-03T14:04:23+08:00">2015-04-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2015-04-07 14:41:00" itemprop="dateModified" datetime="2015-04-07T14:41:00+08:00">2015-04-07</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Aaron OuYang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron OuYang</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  



  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
